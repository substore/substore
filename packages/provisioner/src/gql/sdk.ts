import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: any;
  ISO8601DateTime: any;
  JSON: any;
};

export type AccessToken = Node & {
  __typename?: 'AccessToken';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** Autogenerated return type of AddCertificate */
export type AddCertificatePayload = {
  __typename?: 'AddCertificatePayload';
  app?: Maybe<App>;
  certificate?: Maybe<AppCertificate>;
  check?: Maybe<HostnameCheck>;
  errors?: Maybe<Array<Scalars['String']>>;
};

export type AddOn = Node & {
  __typename?: 'AddOn';
  /** The add-on plan */
  addOnPlan?: Maybe<AddOnPlan>;
  /** DNS hostname for the add-on */
  hostname?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The service name according to the provider */
  name?: Maybe<Scalars['String']>;
  /** Add-on options */
  options?: Maybe<Scalars['JSON']>;
  /** Organization that owns this service */
  organization: Organization;
  /** Password for the add-on */
  password?: Maybe<Scalars['String']>;
  /** Region where the primary instance is deployed */
  primaryRegion?: Maybe<Scalars['String']>;
  /** Private flycast IP address of the add-on */
  privateIp?: Maybe<Scalars['String']>;
  /** Public URL for this service */
  publicUrl?: Maybe<Scalars['String']>;
  /** Regions where replica instances are deployed */
  readRegions?: Maybe<Array<Scalars['String']>>;
};

/** The connection type for AddOn. */
export type AddOnConnection = {
  __typename?: 'AddOnConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddOnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AddOn>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AddOnEdge = {
  __typename?: 'AddOnEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AddOn>;
};

export type AddOnPlan = Node & {
  __typename?: 'AddOnPlan';
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  maxCommandsPerSec?: Maybe<Scalars['Int']>;
  maxConcurrentConnections?: Maybe<Scalars['Int']>;
  maxDailyBandwidth?: Maybe<Scalars['String']>;
  maxDailyCommands?: Maybe<Scalars['Int']>;
  maxDataSize?: Maybe<Scalars['String']>;
  maxRequestSize?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  pricePerMonth?: Maybe<Scalars['Int']>;
};

/** The connection type for AddOnPlan. */
export type AddOnPlanConnection = {
  __typename?: 'AddOnPlanConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddOnPlanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AddOnPlan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AddOnPlanEdge = {
  __typename?: 'AddOnPlanEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AddOnPlan>;
};

export type AddOnProvider = {
  __typename?: 'AddOnProvider';
  excludedRegions?: Maybe<Array<Region>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  regions?: Maybe<Array<Region>>;
};

export enum AddOnType {
  /** A Redis database */
  Redis = 'redis'
}

/** Autogenerated input type of AddWireGuardPeer */
export type AddWireGuardPeerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name with which to refer to the peer */
  name: Scalars['String'];
  /** Add via NATS transaction (deprecated - nats is always used) */
  nats?: InputMaybe<Scalars['Boolean']>;
  /** Network ID to attach wireguard peer to */
  network?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The 25519 public key for the peer */
  pubkey: Scalars['String'];
  /** The region in which to deploy the peer */
  region?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AddWireGuardPeer */
export type AddWireGuardPeerPayload = {
  __typename?: 'AddWireGuardPeerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  endpointip: Scalars['String'];
  network?: Maybe<Scalars['String']>;
  peerip: Scalars['String'];
  pubkey: Scalars['String'];
};

/** Autogenerated input type of AllocateIPAddress */
export type AllocateIpAddressInput = {
  /** The application to allocate the ip address for */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired IP region (defaults to global) */
  region?: InputMaybe<Scalars['String']>;
  /** The type of IP address to allocate (v4, v6, or private_v6) */
  type: IpAddressType;
};

/** Autogenerated return type of AllocateIPAddress */
export type AllocateIpAddressPayload = {
  __typename?: 'AllocateIPAddressPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  ipAddress: IpAddress;
};

export type Allocation = Node & {
  __typename?: 'Allocation';
  attachedVolumes: VolumeConnection;
  canary: Scalars['Boolean'];
  checks: Array<CheckState>;
  createdAt: Scalars['ISO8601DateTime'];
  criticalCheckCount: Scalars['Int'];
  /** Desired status */
  desiredStatus: Scalars['String'];
  events: Array<AllocationEvent>;
  failed: Scalars['Boolean'];
  healthy: Scalars['Boolean'];
  /** Unique ID for this instance */
  id: Scalars['ID'];
  /** Short unique ID for this instance */
  idShort: Scalars['ID'];
  /** Indicates if this instance is from the latest job version */
  latestVersion: Scalars['Boolean'];
  passingCheckCount: Scalars['Int'];
  /** Private IPv6 address for this instance */
  privateIP?: Maybe<Scalars['String']>;
  recentLogs: Array<LogEntry>;
  /** Region this allocation is running in */
  region: Scalars['String'];
  restarts: Scalars['Int'];
  /** Current status */
  status: Scalars['String'];
  taskName: Scalars['String'];
  totalCheckCount: Scalars['Int'];
  transitioning: Scalars['Boolean'];
  updatedAt: Scalars['ISO8601DateTime'];
  /** The configuration version of this instance */
  version: Scalars['Int'];
  warningCheckCount: Scalars['Int'];
};


export type AllocationAttachedVolumesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AllocationChecksArgs = {
  name?: InputMaybe<Scalars['String']>;
};


export type AllocationRecentLogsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  range?: InputMaybe<Scalars['Int']>;
};

export type AllocationEvent = {
  __typename?: 'AllocationEvent';
  message: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
  type: Scalars['String'];
};

export type App = Node & {
  __typename?: 'App';
  allocation?: Maybe<Allocation>;
  allocations: Array<Allocation>;
  appUrl?: Maybe<Scalars['String']>;
  autoscaling?: Maybe<AutoscalingConfig>;
  backupRegions: Array<Region>;
  /**
   * [DEPRECATED] Builds of this application
   * @deprecated Superseded by source_builds
   */
  builds: BuildConnection;
  /** Find a certificate by hostname */
  certificate?: Maybe<AppCertificate>;
  /** Certificates for this app */
  certificates: AppCertificateConnection;
  /** Changes to this application */
  changes: AppChangeConnection;
  config: AppConfig;
  createdAt: Scalars['ISO8601DateTime'];
  currentPlacement: Array<RegionPlacement>;
  /** The latest release of this applicaion */
  currentRelease?: Maybe<Release>;
  deployed: Scalars['Boolean'];
  /** Continuous deployment configuration */
  deploymentSource?: Maybe<DeploymentSource>;
  /** Find a deployment by id, defaults to latest */
  deploymentStatus?: Maybe<DeploymentStatus>;
  /** Check if this app has a configured deployment source */
  hasDeploymentSource: Scalars['Boolean'];
  healthChecks: CheckStateConnection;
  /** Autogenerated hostname for this application */
  hostname?: Maybe<Scalars['String']>;
  /** Unique application ID */
  id: Scalars['ID'];
  /** Resolve an image from a reference */
  image?: Maybe<Image>;
  /** Image details */
  imageDetails?: Maybe<ImageVersion>;
  imageUpgradeAvailable?: Maybe<Scalars['Boolean']>;
  imageVersionTrackingEnabled: Scalars['Boolean'];
  /** Authentication key to use with Instrumentation endpoints */
  instrumentsKey?: Maybe<Scalars['String']>;
  internalId: Scalars['String'];
  internalNumericId: Scalars['Int'];
  /** Find an ip address by address string */
  ipAddress?: Maybe<IpAddress>;
  ipAddresses: IpAddressConnection;
  /** This object's unique key */
  key: Scalars['String'];
  /** Latest image details */
  latestImageDetails?: Maybe<ImageVersion>;
  machine?: Maybe<Machine>;
  machines: MachineConnection;
  /** The unique application name */
  name: Scalars['String'];
  network?: Maybe<Scalars['String']>;
  /** Organization that owns this app */
  organization: Organization;
  parseConfig: AppConfig;
  /** Fly platform version */
  platformVersion?: Maybe<PlatformVersionEnum>;
  processGroups: Array<ProcessGroup>;
  regions: Array<Region>;
  /** Find a specific release */
  release?: Maybe<Release>;
  /** Individual releases for this application */
  releases: ReleaseConnection;
  role?: Maybe<AppRole>;
  /** Application runtime */
  runtime: RuntimeType;
  /** Secrets set on the application */
  secrets: Array<Secret>;
  services: Array<Service>;
  state: AppState;
  /** Application status */
  status: Scalars['String'];
  taskGroupCounts: Array<TaskGroupCount>;
  usage: Array<AppUsage>;
  version: Scalars['Int'];
  vmSize: VmSize;
  vms: VmConnection;
  volume?: Maybe<Volume>;
  /** Volumes associated with app */
  volumes: VolumeConnection;
};


export type AppAllocationArgs = {
  id: Scalars['String'];
};


export type AppAllocationsArgs = {
  showCompleted?: InputMaybe<Scalars['Boolean']>;
};


export type AppBuildsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AppCertificateArgs = {
  hostname: Scalars['String'];
};


export type AppCertificatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AppChangesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AppDeploymentStatusArgs = {
  evaluationId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
};


export type AppHealthChecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};


export type AppImageArgs = {
  ref: Scalars['String'];
};


export type AppIpAddressArgs = {
  address: Scalars['String'];
};


export type AppIpAddressesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AppMachineArgs = {
  id: Scalars['String'];
};


export type AppMachinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  version?: InputMaybe<Scalars['Int']>;
};


export type AppParseConfigArgs = {
  definition: Scalars['JSON'];
};


export type AppReleaseArgs = {
  id?: InputMaybe<Scalars['ID']>;
  version?: InputMaybe<Scalars['Int']>;
};


export type AppReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AppVmsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  showCompleted?: InputMaybe<Scalars['Boolean']>;
};


export type AppVolumeArgs = {
  internalId: Scalars['String'];
};


export type AppVolumesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AppCertificate = Node & {
  __typename?: 'AppCertificate';
  /** @deprecated use isAcmeAlpnConfigured */
  acmeAlpnConfigured: Scalars['Boolean'];
  /** @deprecated use isAcmeDNSConfigured */
  acmeDnsConfigured: Scalars['Boolean'];
  certificateAuthority?: Maybe<Scalars['String']>;
  certificateRequestedAt?: Maybe<Scalars['ISO8601DateTime']>;
  check: Scalars['Boolean'];
  clientStatus: Scalars['String'];
  /** @deprecated use isConfigured */
  configured: Scalars['Boolean'];
  createdAt?: Maybe<Scalars['ISO8601DateTime']>;
  dnsProvider?: Maybe<Scalars['String']>;
  dnsValidationHostname: Scalars['String'];
  dnsValidationInstructions: Scalars['String'];
  dnsValidationTarget: Scalars['String'];
  domain?: Maybe<Scalars['String']>;
  hostname: Scalars['String'];
  id: Scalars['ID'];
  isAcmeAlpnConfigured: Scalars['Boolean'];
  isAcmeDnsConfigured: Scalars['Boolean'];
  isApex: Scalars['Boolean'];
  isConfigured: Scalars['Boolean'];
  isWildcard: Scalars['Boolean'];
  issued: CertificateConnection;
  source?: Maybe<Scalars['String']>;
  validationErrors: Array<AppCertificateValidationError>;
};


export type AppCertificateIssuedArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeExpired?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for AppCertificate. */
export type AppCertificateConnection = {
  __typename?: 'AppCertificateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppCertificateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AppCertificate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AppCertificateEdge = {
  __typename?: 'AppCertificateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AppCertificate>;
};

export type AppCertificateValidationError = {
  __typename?: 'AppCertificateValidationError';
  message: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
};

export type AppChange = Node & {
  __typename?: 'AppChange';
  /** Object that triggered the change */
  actor?: Maybe<AppChangeActor>;
  actorType: Scalars['String'];
  app: App;
  createdAt: Scalars['ISO8601DateTime'];
  description: Scalars['String'];
  id: Scalars['ID'];
  status?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  user?: Maybe<User>;
};

/** Objects that change apps */
export type AppChangeActor = Build | Release | Secret;

/** The connection type for AppChange. */
export type AppChangeConnection = {
  __typename?: 'AppChangeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppChangeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AppChange>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AppChangeEdge = {
  __typename?: 'AppChangeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AppChange>;
};

export type AppConfig = {
  __typename?: 'AppConfig';
  definition: Scalars['JSON'];
  errors: Array<Scalars['String']>;
  services: Array<Service>;
  valid: Scalars['Boolean'];
};

/** The connection type for App. */
export type AppConnection = {
  __typename?: 'AppConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<App>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AppEdge = {
  __typename?: 'AppEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<App>;
};

export type AppRole = {
  /** The name of this role */
  name: Scalars['String'];
};

export enum AppState {
  /** App has been deployed */
  Deployed = 'DEPLOYED',
  /** App has not been deployed */
  Pending = 'PENDING',
  /** App has been suspended */
  Suspended = 'SUSPENDED'
}

/** Application usage data */
export type AppUsage = {
  __typename?: 'AppUsage';
  /** The timespan interval for this usage sample */
  interval: Scalars['String'];
  /** Total requests for this time period */
  requestsCount: Scalars['Int'];
  /** Total app execution time (in seconds) for this time period */
  totalAppExecS: Scalars['Int'];
  /** Total GB transferred out in this time period */
  totalDataOutGB: Scalars['Float'];
  /** The start of the timespan for this usage sample */
  ts: Scalars['ISO8601DateTime'];
};

/** Autogenerated input type of AttachPostgresCluster */
export type AttachPostgresClusterInput = {
  /** The application to attach postgres to */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The database to attach. Defaults to a new database with the same name as the app. */
  databaseName?: InputMaybe<Scalars['String']>;
  /** The database user to create. Defaults to using the database name. */
  databaseUser?: InputMaybe<Scalars['String']>;
  /** Flag used to indicate that flyctl will exec calls */
  manualEntry?: InputMaybe<Scalars['Boolean']>;
  /** The postgres cluster application id */
  postgresClusterAppId: Scalars['ID'];
  /** The environment variable name to set the connection string to. Defaults to DATABASE_URL */
  variableName?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AttachPostgresCluster */
export type AttachPostgresClusterPayload = {
  __typename?: 'AttachPostgresClusterPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  connectionString: Scalars['String'];
  environmentVariableName: Scalars['String'];
  postgresClusterApp: App;
};

export type AutoscaleRegionConfig = {
  __typename?: 'AutoscaleRegionConfig';
  /** The region code */
  code: Scalars['String'];
  /** The minimum number of VMs to run in this region */
  minCount?: Maybe<Scalars['Int']>;
  /** The relative weight for this region */
  weight?: Maybe<Scalars['Int']>;
};

/** Region autoscaling configuration */
export type AutoscaleRegionConfigInput = {
  /** The region code to configure */
  code: Scalars['String'];
  /** Minimum number of VMs to run in this region */
  minCount?: InputMaybe<Scalars['Int']>;
  /** Reset the configuration for this region */
  reset?: InputMaybe<Scalars['Boolean']>;
  /** The weight */
  weight?: InputMaybe<Scalars['Int']>;
};

export enum AutoscaleStrategy {
  /** place vms in regions near connection sources */
  ConnectionSources = 'CONNECTION_SOURCES',
  /** autoscaling is disabled */
  None = 'NONE',
  /** place vms in preferred regions by weight */
  PreferredRegions = 'PREFERRED_REGIONS'
}

export type AutoscalingConfig = {
  __typename?: 'AutoscalingConfig';
  backupRegions: Array<Scalars['String']>;
  balanceRegions: Scalars['Boolean'];
  enabled: Scalars['Boolean'];
  maxCount: Scalars['Int'];
  minCount: Scalars['Int'];
  preferredRegion?: Maybe<Scalars['String']>;
  regions: Array<AutoscaleRegionConfig>;
  strategy: AutoscaleStrategy;
};

export type Billable = {
  __typename?: 'Billable';
  app: App;
  category: Scalars['String'];
  product: Scalars['String'];
  quantity: Scalars['Float'];
  time: Scalars['ISO8601DateTime'];
};

/** The connection type for Billable. */
export type BillableConnection = {
  __typename?: 'BillableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BillableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Billable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BillableEdge = {
  __typename?: 'BillableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Billable>;
};

export enum BillingStatus {
  Current = 'CURRENT',
  PastDue = 'PAST_DUE',
  SourceRequired = 'SOURCE_REQUIRED'
}

export type Build = Node & {
  __typename?: 'Build';
  app: App;
  commitId?: Maybe<Scalars['String']>;
  commitUrl?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  /** The user who initiated the build */
  createdBy?: Maybe<User>;
  /** Indicates if this build is complete and failed */
  failed: Scalars['Boolean'];
  id: Scalars['ID'];
  image?: Maybe<Scalars['String']>;
  /** Indicates if this build is currently in progress */
  inProgress: Scalars['Boolean'];
  /** Log output */
  logs: Scalars['String'];
  number: Scalars['Int'];
  /** Status of the build */
  status: Scalars['String'];
  /** Indicates if this build is complete and succeeded */
  succeeded: Scalars['Boolean'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Build. */
export type BuildConnection = {
  __typename?: 'BuildConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BuildEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Build>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BuildEdge = {
  __typename?: 'BuildEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Build>;
};

export type BuildFinalImageInput = {
  /** Sha256 id of docker image */
  id: Scalars['String'];
  /** Size in bytes of the docker image */
  sizeBytes: Scalars['BigInt'];
  /** Tag used for docker image */
  tag: Scalars['String'];
};

export type BuildImageOptsInput = {
  /** Set of build time variables passed to cli */
  buildArgs?: InputMaybe<Scalars['JSON']>;
  /** Fly.toml build.buildpacks setting */
  buildPacks?: InputMaybe<Array<Scalars['String']>>;
  /** Fly.toml build.builder setting */
  builder?: InputMaybe<Scalars['String']>;
  /** Builtin builder to use */
  builtIn?: InputMaybe<Scalars['String']>;
  /** Builtin builder settings */
  builtInSettings?: InputMaybe<Scalars['JSON']>;
  /** Path to dockerfile, if one exists */
  dockerfilePath?: InputMaybe<Scalars['String']>;
  /** Unused in cli? */
  extraBuildArgs?: InputMaybe<Scalars['JSON']>;
  /** Image label to use when tagging and pushing to the fly registry */
  imageLabel?: InputMaybe<Scalars['String']>;
  /** Unused in cli? */
  imageRef?: InputMaybe<Scalars['String']>;
  /** Do not use the build cache when building the image */
  noCache?: InputMaybe<Scalars['Boolean']>;
  /** Whether publishing to the registry was requested */
  publish?: InputMaybe<Scalars['Boolean']>;
  /** Docker tag used to publish image to registry */
  tag?: InputMaybe<Scalars['String']>;
  /** Set the target build stage to build if the Dockerfile has more than one stage */
  target?: InputMaybe<Scalars['String']>;
};

export type BuildStrategyAttemptInput = {
  /** Optional error message from strategy */
  error?: InputMaybe<Scalars['String']>;
  /** Optional note about this strategy or its result */
  note?: InputMaybe<Scalars['String']>;
  /** Result attempting this strategy */
  result: Scalars['String'];
  /** Build strategy attempted */
  strategy: Scalars['String'];
};

export type BuildTimingsInput = {
  /** Time to build and push the image, measured by flyctl */
  buildAndPushMs?: InputMaybe<Scalars['BigInt']>;
  /** Time to build the image including create context, measured by flyctl */
  buildMs?: InputMaybe<Scalars['BigInt']>;
  /** Time to initialize client used to connect to either remote or local builder */
  builderInitMs?: InputMaybe<Scalars['BigInt']>;
  /** Time to create the build context tar file, measured by flyctl */
  contextBuildMs?: InputMaybe<Scalars['BigInt']>;
  /** Time for builder to build image after receiving context, measured by flyctl */
  imageBuildMs?: InputMaybe<Scalars['BigInt']>;
  /** Time to push completed image to registry, measured by flyctl */
  pushMs?: InputMaybe<Scalars['BigInt']>;
};

export type BuilderMetaInput = {
  /** Local or remote builder type */
  builderType: Scalars['String'];
  /** Whther or not buildkit is enabled on builder */
  buildkitEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Docker version reported by builder */
  dockerVersion?: InputMaybe<Scalars['String']>;
  /** Platform reported by the builder */
  platform?: InputMaybe<Scalars['String']>;
  /** Remote builder app used */
  remoteAppName?: InputMaybe<Scalars['ID']>;
  /** Remote builder machine used */
  remoteMachineId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CancelBuild */
export type CancelBuildPayload = {
  __typename?: 'CancelBuildPayload';
  build: Build;
};

export type Certificate = Node & {
  __typename?: 'Certificate';
  expiresAt: Scalars['ISO8601DateTime'];
  hostname: Scalars['String'];
  id: Scalars['ID'];
  type: Scalars['String'];
};

/** The connection type for Certificate. */
export type CertificateConnection = {
  __typename?: 'CertificateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertificateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Certificate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CertificateEdge = {
  __typename?: 'CertificateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Certificate>;
};

/** health check */
export type Check = {
  __typename?: 'Check';
  httpHeaders?: Maybe<Array<CheckHeader>>;
  httpMethod?: Maybe<Scalars['String']>;
  httpPath?: Maybe<Scalars['String']>;
  httpProtocol?: Maybe<HttpProtocol>;
  httpTlsSkipVerify?: Maybe<Scalars['Boolean']>;
  /** Check interval in milliseconds */
  interval: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  scriptArgs?: Maybe<Array<Scalars['String']>>;
  scriptCommand?: Maybe<Scalars['String']>;
  /** Check timeout in milliseconds */
  timeout: Scalars['Int'];
  type: CheckType;
};

/** Autogenerated input type of CheckCertificate */
export type CheckCertificateInput = {
  /** Application to ID */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Certificate hostname to check */
  hostname: Scalars['String'];
};

/** Autogenerated return type of CheckCertificate */
export type CheckCertificatePayload = {
  __typename?: 'CheckCertificatePayload';
  app?: Maybe<App>;
  certificate?: Maybe<AppCertificate>;
  check?: Maybe<HostnameCheck>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CheckDomain */
export type CheckDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Domain name to check */
  domainName: Scalars['String'];
};

/** Autogenerated return type of CheckDomain */
export type CheckDomainPayload = {
  __typename?: 'CheckDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  dnsAvailable: Scalars['Boolean'];
  domainName: Scalars['String'];
  registrationAvailable: Scalars['Boolean'];
  registrationPeriod?: Maybe<Scalars['Int']>;
  registrationPrice?: Maybe<Scalars['Int']>;
  registrationSupported: Scalars['Boolean'];
  tld: Scalars['String'];
  transferAvailable: Scalars['Boolean'];
};

/** check job http response */
export type CheckHttpResponse = Node & {
  __typename?: 'CheckHTTPResponse';
  closeTs: Scalars['String'];
  connectedTs: Scalars['String'];
  dnsTs: Scalars['String'];
  firstTs: Scalars['String'];
  flyioDebug?: Maybe<Scalars['JSON']>;
  headers: Scalars['JSON'];
  id: Scalars['ID'];
  lastTs: Scalars['String'];
  location: CheckLocation;
  rawHeaders: Scalars['String'];
  rawOutput: Array<Scalars['String']>;
  resolvedIp: Scalars['String'];
  sentTs: Scalars['String'];
  startTs: Scalars['String'];
  statusCode: Scalars['Int'];
  tlsTs?: Maybe<Scalars['String']>;
};

/** The connection type for CheckHTTPResponse. */
export type CheckHttpResponseConnection = {
  __typename?: 'CheckHTTPResponseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckHttpResponseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckHttpResponse>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CheckHttpResponseEdge = {
  __typename?: 'CheckHTTPResponseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckHttpResponse>;
};

/** All available http checks verbs */
export enum CheckHttpVerb {
  Get = 'GET',
  Head = 'HEAD'
}

/** HTTP header for a health check */
export type CheckHeader = {
  __typename?: 'CheckHeader';
  name: Scalars['String'];
  value: Scalars['String'];
};

export type CheckHeaderInput = {
  name: Scalars['String'];
  value: Scalars['String'];
};

export type CheckInput = {
  httpHeaders?: InputMaybe<Array<CheckHeaderInput>>;
  httpMethod?: InputMaybe<HttpMethod>;
  httpPath?: InputMaybe<Scalars['String']>;
  httpProtocol?: InputMaybe<HttpProtocol>;
  httpTlsSkipVerify?: InputMaybe<Scalars['Boolean']>;
  /** Check interval in milliseconds */
  interval?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  scriptArgs?: InputMaybe<Array<Scalars['String']>>;
  scriptCommand?: InputMaybe<Scalars['String']>;
  /** Check timeout in milliseconds */
  timeout?: InputMaybe<Scalars['Int']>;
  type: CheckType;
};

/** check job */
export type CheckJob = Node & {
  __typename?: 'CheckJob';
  httpOptions?: Maybe<CheckJobHttpOptions>;
  id: Scalars['ID'];
  locations: CheckLocationConnection;
  nextRunAt?: Maybe<Scalars['ISO8601DateTime']>;
  runs: CheckJobRunConnection;
  schedule?: Maybe<Scalars['String']>;
  url: Scalars['String'];
};


/** check job */
export type CheckJobLocationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** check job */
export type CheckJobRunsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CheckJob. */
export type CheckJobConnection = {
  __typename?: 'CheckJobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CheckJobEdge = {
  __typename?: 'CheckJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckJob>;
};

/** health check state */
export type CheckJobHttpOptions = {
  __typename?: 'CheckJobHTTPOptions';
  headers: Array<Scalars['String']>;
  verb: CheckHttpVerb;
};

/** health check state */
export type CheckJobHttpOptionsInput = {
  headers?: InputMaybe<Array<Scalars['String']>>;
  verb?: CheckHttpVerb;
};

/** check job run */
export type CheckJobRun = Node & {
  __typename?: 'CheckJobRun';
  completedAt?: Maybe<Scalars['ISO8601DateTime']>;
  createdAt: Scalars['ISO8601DateTime'];
  httpOptions: CheckJobHttpOptions;
  httpResponses: CheckHttpResponseConnection;
  id: Scalars['ID'];
  locations: CheckLocationConnection;
  state: Scalars['String'];
  tests: Array<Scalars['String']>;
  url: Scalars['String'];
};


/** check job run */
export type CheckJobRunHttpResponsesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** check job run */
export type CheckJobRunLocationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CheckJobRun. */
export type CheckJobRunConnection = {
  __typename?: 'CheckJobRunConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckJobRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckJobRun>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CheckJobRunEdge = {
  __typename?: 'CheckJobRunEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckJobRun>;
};

/** check location */
export type CheckLocation = {
  __typename?: 'CheckLocation';
  coordinates: Array<Scalars['Float']>;
  country: Scalars['String'];
  locality: Scalars['String'];
  name: Scalars['String'];
  state?: Maybe<Scalars['String']>;
  title: Scalars['String'];
};

/** The connection type for CheckLocation. */
export type CheckLocationConnection = {
  __typename?: 'CheckLocationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckLocationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckLocation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CheckLocationEdge = {
  __typename?: 'CheckLocationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckLocation>;
};

/** health check state */
export type CheckState = {
  __typename?: 'CheckState';
  allocation: Allocation;
  allocationId: Scalars['String'];
  name: Scalars['String'];
  output: Scalars['String'];
  serviceName: Scalars['String'];
  status: Scalars['String'];
  type: CheckType;
  updatedAt: Scalars['ISO8601DateTime'];
};


/** health check state */
export type CheckStateOutputArgs = {
  compact?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CheckState. */
export type CheckStateConnection = {
  __typename?: 'CheckStateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckStateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckState>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CheckStateEdge = {
  __typename?: 'CheckStateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckState>;
};

export enum CheckType {
  /** http health check */
  Http = 'HTTP',
  /** script health check */
  Script = 'SCRIPT',
  /** tcp health check */
  Tcp = 'TCP'
}

/** Autogenerated input type of ConfigureRegions */
export type ConfigureRegionsInput = {
  /** Regions to allow running in */
  allowRegions?: InputMaybe<Array<Scalars['String']>>;
  /** The ID of the app */
  appId: Scalars['ID'];
  /** Fallback regions. Used if preferred regions are having issues */
  backupRegions?: InputMaybe<Array<Scalars['String']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Regions to deny running in */
  denyRegions?: InputMaybe<Array<Scalars['String']>>;
  /** Process group to modify */
  group?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConfigureRegions */
export type ConfigureRegionsPayload = {
  __typename?: 'ConfigureRegionsPayload';
  app: App;
  backupRegions: Array<Region>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group?: Maybe<Scalars['String']>;
  regions: Array<Region>;
};

/** Autogenerated input type of CreateAddOn */
export type CreateAddOnInput = {
  /** An optional application ID to attach the add-on to after provisioning */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An optional name for the add-on */
  name?: InputMaybe<Scalars['String']>;
  /** Options specific to the add-on */
  options?: InputMaybe<Scalars['JSON']>;
  /** The organization which owns the add-on */
  organizationId?: InputMaybe<Scalars['ID']>;
  /** The add-on plan ID */
  planId: Scalars['ID'];
  /** Desired primary region for the add-on */
  primaryRegion: Scalars['String'];
  /** Desired regions to place replicas in */
  readRegions?: InputMaybe<Array<Scalars['String']>>;
  /** The add-on type to provision */
  type: AddOnType;
};

/** Autogenerated return type of CreateAddOn */
export type CreateAddOnPayload = {
  __typename?: 'CreateAddOnPayload';
  addOn: AddOn;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateAndRegisterDomain */
export type CreateAndRegisterDomainInput = {
  /** Enable auto renew on the registration */
  autoRenew?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The domain name */
  name: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** Enable whois privacy on the registration */
  whoisPrivacy?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of CreateAndRegisterDomain */
export type CreateAndRegisterDomainPayload = {
  __typename?: 'CreateAndRegisterDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
  organization: Organization;
};

/** Autogenerated input type of CreateAndTransferDomain */
export type CreateAndTransferDomainInput = {
  /** The authorization code */
  authorizationCode: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The domain name */
  name: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of CreateAndTransferDomain */
export type CreateAndTransferDomainPayload = {
  __typename?: 'CreateAndTransferDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
  organization: Organization;
};

/** Autogenerated input type of CreateApp */
export type CreateAppInput = {
  appRoleId?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  heroku?: InputMaybe<Scalars['Boolean']>;
  machines?: InputMaybe<Scalars['Boolean']>;
  /** The name of the new application. Defaults to a random name. */
  name?: InputMaybe<Scalars['String']>;
  network?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  preferredRegion?: InputMaybe<Scalars['String']>;
  /** The application runtime */
  runtime?: InputMaybe<RuntimeType>;
};

/** Autogenerated return type of CreateApp */
export type CreateAppPayload = {
  __typename?: 'CreateAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateBuild */
export type CreateBuildInput = {
  /** The name of the app being built */
  appName: Scalars['ID'];
  /** Whether builder is remote or local */
  builderType: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Options set for building image */
  imageOpts: BuildImageOptsInput;
  /** The ID of the machine being built (only set for machine builds) */
  machineId?: InputMaybe<Scalars['ID']>;
  /** List of available build strategies that will be attempted */
  strategiesAvailable: Array<Scalars['String']>;
};

/** Autogenerated return type of CreateBuild */
export type CreateBuildPayload = {
  __typename?: 'CreateBuildPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** build id */
  id: Scalars['ID'];
  /** stored build status */
  status: Scalars['String'];
};

/** Autogenerated input type of CreateCheckJob */
export type CreateCheckJobInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** http check options */
  httpOptions: CheckJobHttpOptionsInput;
  /** http checks locations */
  locations: Array<Scalars['String']>;
  /** Organization ID */
  organizationId: Scalars['ID'];
  /** The URL to check */
  url: Scalars['String'];
};

/** Autogenerated return type of CreateCheckJob */
export type CreateCheckJobPayload = {
  __typename?: 'CreateCheckJobPayload';
  checkJob: CheckJob;
  checkJobRun?: Maybe<CheckJobRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckJobRun */
export type CreateCheckJobRunInput = {
  /** Check Job ID */
  checkJobId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateCheckJobRun */
export type CreateCheckJobRunPayload = {
  __typename?: 'CreateCheckJobRunPayload';
  checkJob: CheckJob;
  checkJobRun?: Maybe<CheckJobRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateDNSPortal */
export type CreateDnsPortalInput = {
  /** The secondary branding color */
  accentColor?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The unique name of this portal. A random name will be generated if omitted. */
  name?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The primary branding color */
  primaryColor?: InputMaybe<Scalars['String']>;
  /** The return url for this portal */
  returnUrl?: InputMaybe<Scalars['String']>;
  /** The text to display for the return url link */
  returnUrlText?: InputMaybe<Scalars['String']>;
  /** The support url for this portal */
  supportUrl?: InputMaybe<Scalars['String']>;
  /** The text to display for the support url link */
  supportUrlText?: InputMaybe<Scalars['String']>;
  /** The title of this portal */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateDNSPortal */
export type CreateDnsPortalPayload = {
  __typename?: 'CreateDNSPortalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  dnsPortal: DnsPortal;
};

/** Autogenerated input type of CreateDNSPortalSession */
export type CreateDnsPortalSessionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the dns portal */
  dnsPortalId: Scalars['ID'];
  /** The node ID of the domain to edit */
  domainId: Scalars['ID'];
  /** Optionally override the portal's default return url for this session */
  returnUrl?: InputMaybe<Scalars['String']>;
  /** Optionally override the portal's default return url text for this session */
  returnUrlText?: InputMaybe<Scalars['String']>;
  /** Optionally override the portal's default title for this session */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateDNSPortalSession */
export type CreateDnsPortalSessionPayload = {
  __typename?: 'CreateDNSPortalSessionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  dnsPortalSession: DnsPortalSession;
};

/** Autogenerated input type of CreateDNSRecord */
export type CreateDnsRecordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the domain */
  domainId: Scalars['ID'];
  /** The dns record name */
  name: Scalars['String'];
  /** The content of the record */
  rdata: Scalars['String'];
  /** The TTL in seconds */
  ttl: Scalars['Int'];
  /** The type of the record */
  type: DnsRecordType;
};

/** Autogenerated return type of CreateDNSRecord */
export type CreateDnsRecordPayload = {
  __typename?: 'CreateDNSRecordPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  record: DnsRecord;
};

/** Autogenerated input type of CreateDelegatedWireGuardToken */
export type CreateDelegatedWireGuardTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name with which to refer to the peer */
  name?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of CreateDelegatedWireGuardToken */
export type CreateDelegatedWireGuardTokenPayload = {
  __typename?: 'CreateDelegatedWireGuardTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  token: Scalars['String'];
};

/** Autogenerated input type of CreateDoctorReport */
export type CreateDoctorReportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The report data */
  data: Scalars['JSON'];
};

/** Autogenerated return type of CreateDoctorReport */
export type CreateDoctorReportPayload = {
  __typename?: 'CreateDoctorReportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  reportId: Scalars['ID'];
};

/** Autogenerated return type of CreateDoctorUrl */
export type CreateDoctorUrlPayload = {
  __typename?: 'CreateDoctorUrlPayload';
  putUrl: Scalars['String'];
};

/** Autogenerated input type of CreateDomain */
export type CreateDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The domain name */
  name: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of CreateDomain */
export type CreateDomainPayload = {
  __typename?: 'CreateDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
  organization: Organization;
};

/** Autogenerated input type of CreateOrganization */
export type CreateOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the organization */
  name: Scalars['String'];
};

/** Autogenerated input type of CreateOrganizationInvitation */
export type CreateOrganizationInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The email to invite */
  email: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of CreateOrganizationInvitation */
export type CreateOrganizationInvitationPayload = {
  __typename?: 'CreateOrganizationInvitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  invitation: OrganizationInvitation;
};

/** Autogenerated return type of CreateOrganization */
export type CreateOrganizationPayload = {
  __typename?: 'CreateOrganizationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
};

/** Autogenerated input type of CreatePostgresClusterDatabase */
export type CreatePostgresClusterDatabaseInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the database */
  databaseName: Scalars['String'];
};

/** Autogenerated return type of CreatePostgresClusterDatabase */
export type CreatePostgresClusterDatabasePayload = {
  __typename?: 'CreatePostgresClusterDatabasePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  database: PostgresClusterDatabase;
  postgresClusterRole: PostgresClusterAppRole;
};

/** Autogenerated input type of CreatePostgresCluster */
export type CreatePostgresClusterInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Number of VM's to provision */
  count?: InputMaybe<Scalars['Int']>;
  imageRef?: InputMaybe<Scalars['String']>;
  /** The name of the new application. Defaults to a random name. */
  name?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The superuser password. Defaults to a random password. */
  password?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  snapshotId?: InputMaybe<Scalars['ID']>;
  /** The VM size to use. Defaults to shared-cpu-1x */
  vmSize?: InputMaybe<Scalars['String']>;
  /** The volume size in GB. Defaults to 10. */
  volumeSizeGb?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of CreatePostgresCluster */
export type CreatePostgresClusterPayload = {
  __typename?: 'CreatePostgresClusterPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  password: Scalars['String'];
  username: Scalars['String'];
};

/** Autogenerated input type of CreatePostgresClusterUser */
export type CreatePostgresClusterUserInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The password of the user */
  password: Scalars['String'];
  /** Should this user be a superuser */
  superuser?: InputMaybe<Scalars['Boolean']>;
  /** The name of the database */
  username: Scalars['String'];
};

/** Autogenerated return type of CreatePostgresClusterUser */
export type CreatePostgresClusterUserPayload = {
  __typename?: 'CreatePostgresClusterUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  postgresClusterRole: PostgresClusterAppRole;
  user: PostgresClusterUser;
};

/** Autogenerated input type of CreateTemplateDeployment */
export type CreateTemplateDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization to move the app to */
  organizationId: Scalars['ID'];
  template: Scalars['JSON'];
  variables?: InputMaybe<Array<PropertyInput>>;
};

/** Autogenerated return type of CreateTemplateDeployment */
export type CreateTemplateDeploymentPayload = {
  __typename?: 'CreateTemplateDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  templateDeployment: TemplateDeployment;
};

/** Autogenerated input type of CreateVolume */
export type CreateVolumeInput = {
  /** The application to attach the new volume to */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Volume should be encrypted at rest */
  encrypted?: InputMaybe<Scalars['Boolean']>;
  /** Volume name */
  name: Scalars['String'];
  /** Desired region for volume */
  region: Scalars['String'];
  /** Provision volume in a redundancy zone not already in use by this app */
  requireUniqueZone?: InputMaybe<Scalars['Boolean']>;
  /** Desired volume size, in GB */
  sizeGb: Scalars['Int'];
  snapshotId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateVolume */
export type CreateVolumePayload = {
  __typename?: 'CreateVolumePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  volume: Volume;
};

/** Autogenerated input type of CreateVolumeSnapshot */
export type CreateVolumeSnapshotInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  volumeId: Scalars['ID'];
};

/** Autogenerated return type of CreateVolumeSnapshot */
export type CreateVolumeSnapshotPayload = {
  __typename?: 'CreateVolumeSnapshotPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  volume: Volume;
};

export type DnsPortal = Node & {
  __typename?: 'DNSPortal';
  accentColor: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  organiztion: Organization;
  primaryColor: Scalars['String'];
  returnUrl?: Maybe<Scalars['String']>;
  returnUrlText?: Maybe<Scalars['String']>;
  supportUrl?: Maybe<Scalars['String']>;
  supportUrlText?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for DNSPortal. */
export type DnsPortalConnection = {
  __typename?: 'DNSPortalConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DnsPortalEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DnsPortal>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DnsPortalEdge = {
  __typename?: 'DNSPortalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DnsPortal>;
};

export type DnsPortalSession = Node & {
  __typename?: 'DNSPortalSession';
  createdAt: Scalars['ISO8601DateTime'];
  /** The dns portal this session */
  dnsPortal: DnsPortal;
  expiresAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  /** Is this session expired? */
  isExpired: Scalars['Boolean'];
  /** The overridden return url for this session */
  returnUrl?: Maybe<Scalars['String']>;
  /** The overridden return url text for this session */
  returnUrlText?: Maybe<Scalars['String']>;
  /** The overridden title for this session */
  title?: Maybe<Scalars['String']>;
  /** The url to access this session's dns portal */
  url: Scalars['String'];
};

export type DnsRecord = Node & {
  __typename?: 'DNSRecord';
  createdAt: Scalars['ISO8601DateTime'];
  /** The domain this record belongs to */
  domain: Domain;
  /** Fully qualified domain name for this record */
  fqdn: Scalars['String'];
  id: Scalars['ID'];
  /** Is this record at the zone apex? */
  isApex: Scalars['Boolean'];
  /** Is this a system record? System records are managed by fly and not editable. */
  isSystem: Scalars['Boolean'];
  /** Is this record a wildcard? */
  isWildcard: Scalars['Boolean'];
  /** The name of this record. @ indicates the record is at the zone apex. */
  name: Scalars['String'];
  /** The record data */
  rdata: Scalars['String'];
  /** The number of seconds this record can be cached for */
  ttl: Scalars['Int'];
  /** The type of record */
  type: DnsRecordType;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type DnsRecordAttributes = {
  __typename?: 'DNSRecordAttributes';
  /** The name of the record. */
  name: Scalars['String'];
  /** The record data. */
  rdata: Scalars['String'];
  /** The number of seconds this record can be cached for. */
  ttl: Scalars['Int'];
  /** The type of record. */
  type: DnsRecordType;
};

export enum DnsRecordChangeAction {
  /** A record should be created with the provided attributes */
  Create = 'CREATE',
  /** A record with the provided ID should be deleted */
  Delete = 'DELETE',
  /** A record with the provided ID should be updated */
  Update = 'UPDATE'
}

export type DnsRecordChangeInput = {
  /** The action to perform on this record. */
  action: DnsRecordChangeAction;
  /** The name of the record. If omitted it will default to @ - the zone apex. */
  name?: InputMaybe<Scalars['String']>;
  /** The record data. Required if action is CREATE */
  rdata?: InputMaybe<Scalars['String']>;
  /** The id of the record this action will apply to. This is required if the action is UPDATE or DELETE. */
  recordId?: InputMaybe<Scalars['ID']>;
  /** The number of seconds this record can be cached for. Defaults to 1 hour. */
  ttl?: InputMaybe<Scalars['Int']>;
  /** The record type. This is required if action is CREATE. */
  type?: InputMaybe<DnsRecordType>;
};

/** The connection type for DNSRecord. */
export type DnsRecordConnection = {
  __typename?: 'DNSRecordConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DnsRecordEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DnsRecord>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type DnsRecordDiff = {
  __typename?: 'DNSRecordDiff';
  /** The action that was performed. */
  action: DnsRecordChangeAction;
  /** The attributes for this record after the action was performed. */
  newAttributes?: Maybe<DnsRecordAttributes>;
  /** The text representation of this record after the action was performed. */
  newText?: Maybe<Scalars['String']>;
  /** The attributes for this record before the action was performed. */
  oldAttributes?: Maybe<DnsRecordAttributes>;
  /** The text representation of this record before the action was performed. */
  oldText?: Maybe<Scalars['String']>;
};

/** An edge in a connection. */
export type DnsRecordEdge = {
  __typename?: 'DNSRecordEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DnsRecord>;
};

export enum DnsRecordType {
  A = 'A',
  Aaaa = 'AAAA',
  Alias = 'ALIAS',
  Cname = 'CNAME',
  Mx = 'MX',
  Ns = 'NS',
  Soa = 'SOA',
  Srv = 'SRV',
  Txt = 'TXT'
}

export type DnsRecordWarning = {
  __typename?: 'DNSRecordWarning';
  /** The action to perform. */
  action: DnsRecordChangeAction;
  /** The desired attributes for this record. */
  attributes: DnsRecordAttributes;
  /** The warning message. */
  message: Scalars['String'];
  /** The record this warning applies to. */
  record?: Maybe<DnsRecord>;
};

export type DelegatedWireGuardToken = Node & {
  __typename?: 'DelegatedWireGuardToken';
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** The connection type for DelegatedWireGuardToken. */
export type DelegatedWireGuardTokenConnection = {
  __typename?: 'DelegatedWireGuardTokenConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DelegatedWireGuardTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DelegatedWireGuardToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DelegatedWireGuardTokenEdge = {
  __typename?: 'DelegatedWireGuardTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DelegatedWireGuardToken>;
};

/** Autogenerated input type of DeleteAddOn */
export type DeleteAddOnInput = {
  /** The ID of the add-on to delete */
  addOnId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the add-on to delete */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteAddOn */
export type DeleteAddOnPayload = {
  __typename?: 'DeleteAddOnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedAddOnName?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteApp */
export type DeleteAppPayload = {
  __typename?: 'DeleteAppPayload';
  /** The organization that owned the deleted app */
  organization: Organization;
};

/** Autogenerated return type of DeleteCertificate */
export type DeleteCertificatePayload = {
  __typename?: 'DeleteCertificatePayload';
  app?: Maybe<App>;
  certificate?: Maybe<AppCertificate>;
  errors?: Maybe<Array<Scalars['String']>>;
};

/** Autogenerated input type of DeleteDNSPortal */
export type DeleteDnsPortalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the dns portal */
  dnsPortalId: Scalars['ID'];
};

/** Autogenerated return type of DeleteDNSPortal */
export type DeleteDnsPortalPayload = {
  __typename?: 'DeleteDNSPortalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization that owned the dns portal */
  organization: Organization;
};

/** Autogenerated input type of DeleteDNSPortalSession */
export type DeleteDnsPortalSessionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the dns portal session */
  dnsPortalSessionId: Scalars['ID'];
};

/** Autogenerated return type of DeleteDNSPortalSession */
export type DeleteDnsPortalSessionPayload = {
  __typename?: 'DeleteDNSPortalSessionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The dns portal that owned the session */
  dnsPortal: DnsPortal;
};

/** Autogenerated input type of DeleteDNSRecord */
export type DeleteDnsRecordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the DNS record */
  recordId: Scalars['ID'];
};

/** Autogenerated return type of DeleteDNSRecord */
export type DeleteDnsRecordPayload = {
  __typename?: 'DeleteDNSRecordPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
};

/** Autogenerated input type of DeleteDelegatedWireGuardToken */
export type DeleteDelegatedWireGuardTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name with which to refer to the token */
  name?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The raw WireGuard token */
  token?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteDelegatedWireGuardToken */
export type DeleteDelegatedWireGuardTokenPayload = {
  __typename?: 'DeleteDelegatedWireGuardTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  token: Scalars['String'];
};

/** Autogenerated input type of DeleteDeploymentSource */
export type DeleteDeploymentSourceInput = {
  /** The application to update */
  appId: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteDeploymentSource */
export type DeleteDeploymentSourcePayload = {
  __typename?: 'DeleteDeploymentSourcePayload';
  app?: Maybe<App>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDomain */
export type DeleteDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the domain */
  domainId: Scalars['ID'];
};

/** Autogenerated return type of DeleteDomain */
export type DeleteDomainPayload = {
  __typename?: 'DeleteDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
};

/** Autogenerated input type of DeleteHealthCheckHandler */
export type DeleteHealthCheckHandlerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Handler name */
  name: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of DeleteHealthCheckHandler */
export type DeleteHealthCheckHandlerPayload = {
  __typename?: 'DeleteHealthCheckHandlerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteOrganization */
export type DeleteOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization to delete */
  organizationId: Scalars['ID'];
};

/** Autogenerated input type of DeleteOrganizationInvitation */
export type DeleteOrganizationInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the invitation */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of DeleteOrganizationInvitation */
export type DeleteOrganizationInvitationPayload = {
  __typename?: 'DeleteOrganizationInvitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
};

/** Autogenerated input type of DeleteOrganizationMembership */
export type DeleteOrganizationMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The node ID of the user */
  userId: Scalars['ID'];
};

/** Autogenerated return type of DeleteOrganizationMembership */
export type DeleteOrganizationMembershipPayload = {
  __typename?: 'DeleteOrganizationMembershipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
  user: User;
};

/** Autogenerated return type of DeleteOrganization */
export type DeleteOrganizationPayload = {
  __typename?: 'DeleteOrganizationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedOrganizationId: Scalars['ID'];
};

/** Autogenerated input type of DeleteRemoteBuilder */
export type DeleteRemoteBuilderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of DeleteRemoteBuilder */
export type DeleteRemoteBuilderPayload = {
  __typename?: 'DeleteRemoteBuilderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
};

/** Autogenerated input type of DeleteVolume */
export type DeleteVolumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the volume */
  volumeId: Scalars['ID'];
};

/** Autogenerated return type of DeleteVolume */
export type DeleteVolumePayload = {
  __typename?: 'DeleteVolumePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeployImage */
export type DeployImageInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** app definition */
  definition?: InputMaybe<Scalars['JSON']>;
  /** The image to deploy */
  image: Scalars['String'];
  /** Network services to expose */
  services?: InputMaybe<Array<ServiceInput>>;
  /** The strategy for replacing existing instances. Defaults to canary. */
  strategy?: InputMaybe<DeploymentStrategy>;
};

/** Autogenerated return type of DeployImage */
export type DeployImagePayload = {
  __typename?: 'DeployImagePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  release?: Maybe<Release>;
  releaseCommand?: Maybe<ReleaseCommand>;
};

/** Continuous deployment configuration */
export type DeploymentSource = {
  __typename?: 'DeploymentSource';
  backend: Scalars['JSON'];
  baseDir: Scalars['String'];
  connected: Scalars['Boolean'];
  id: Scalars['ID'];
  provider: Scalars['String'];
  /** The ref to build from */
  ref: Scalars['String'];
  repositoryId: Scalars['String'];
  /** The repository to fetch source code from */
  repositoryUrl: Scalars['String'];
};

export type DeploymentStatus = {
  __typename?: 'DeploymentStatus';
  allocations: Array<Allocation>;
  description: Scalars['String'];
  desiredCount: Scalars['Int'];
  healthyCount: Scalars['Int'];
  /** Unique ID for this deployment */
  id: Scalars['ID'];
  inProgress: Scalars['Boolean'];
  placedCount: Scalars['Int'];
  promoted: Scalars['Boolean'];
  status: Scalars['String'];
  successful: Scalars['Boolean'];
  unhealthyCount: Scalars['Int'];
  version: Scalars['Int'];
};

export enum DeploymentStrategy {
  /** Launch all new instances before shutting down previous instances */
  Bluegreen = 'BLUEGREEN',
  /** Ensure new instances are healthy before continuing with a rolling deployment */
  Canary = 'CANARY',
  /** Deploy new instances all at once */
  Immediate = 'IMMEDIATE',
  /** Incrementally replace old instances with new ones */
  Rolling = 'ROLLING',
  /** Incrementally replace old instances with new ones, 1 by 1 */
  RollingOne = 'ROLLING_ONE',
  /** Deploy new instances all at once */
  Simple = 'SIMPLE'
}

/** Autogenerated input type of DetachPostgresCluster */
export type DetachPostgresClusterInput = {
  /** The application to detach postgres from */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The postgres cluster application id */
  postgresClusterAppId: Scalars['ID'];
  /** The postgres attachment id */
  postgresClusterAttachmentId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of DetachPostgresCluster */
export type DetachPostgresClusterPayload = {
  __typename?: 'DetachPostgresClusterPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  postgresClusterApp: App;
};

export type Domain = Node & {
  __typename?: 'Domain';
  autoRenew?: Maybe<Scalars['Boolean']>;
  createdAt: Scalars['ISO8601DateTime'];
  /** The delegated nameservers for the registration */
  delegatedNameservers?: Maybe<Array<Scalars['String']>>;
  /** The dns records for this domain */
  dnsRecords: DnsRecordConnection;
  dnsStatus: DomainDnsStatus;
  expiresAt?: Maybe<Scalars['ISO8601DateTime']>;
  id: Scalars['ID'];
  /** The name for this domain */
  name: Scalars['String'];
  /** The organization that owns this domain */
  organization: Organization;
  registrationStatus: DomainRegistrationStatus;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The nameservers for the hosted zone */
  zoneNameservers: Array<Scalars['String']>;
};


export type DomainDnsRecordsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Domain. */
export type DomainConnection = {
  __typename?: 'DomainConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DomainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Domain>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export enum DomainDnsStatus {
  /** The DNS zone has not been created yet */
  Pending = 'PENDING',
  /** The DNS zone is ready */
  Ready = 'READY',
  /** The DNS zone is being updated */
  Updating = 'UPDATING'
}

/** An edge in a connection. */
export type DomainEdge = {
  __typename?: 'DomainEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Domain>;
};

export enum DomainRegistrationStatus {
  /** The domain registration has expired */
  Expired = 'EXPIRED',
  /** The domain is registered */
  Registered = 'REGISTERED',
  /** The domain is being registered */
  Registering = 'REGISTERING',
  /** The domain is being transferred */
  Transferring = 'TRANSFERRING',
  /** The domain is not registered on fly */
  Unmanaged = 'UNMANAGED'
}

/** Autogenerated input type of DummyWireGuardPeer */
export type DummyWireGuardPeerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The region in which to deploy the peer */
  region?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DummyWireGuardPeer */
export type DummyWireGuardPeerPayload = {
  __typename?: 'DummyWireGuardPeerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  endpointip: Scalars['String'];
  localpub: Scalars['String'];
  peerip: Scalars['String'];
  privkey: Scalars['String'];
  pubkey: Scalars['String'];
};

export type EmptyAppRole = AppRole & {
  __typename?: 'EmptyAppRole';
  /** The name of this role */
  name: Scalars['String'];
};

/** Autogenerated input type of EnablePostgresConsul */
export type EnablePostgresConsulInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of EnablePostgresConsul */
export type EnablePostgresConsulPayload = {
  __typename?: 'EnablePostgresConsulPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  consulUrl: Scalars['String'];
};

/** Autogenerated input type of EnsureMachineRemoteBuilder */
export type EnsureMachineRemoteBuilderInput = {
  /** The unique application name */
  appName?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId?: InputMaybe<Scalars['ID']>;
  /** Desired region for the remote builder */
  region?: InputMaybe<Scalars['String']>;
  /** Use v2 machines */
  v2?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of EnsureMachineRemoteBuilder */
export type EnsureMachineRemoteBuilderPayload = {
  __typename?: 'EnsureMachineRemoteBuilderPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  machine: Machine;
};

/** Autogenerated input type of EstablishSSHKey */
export type EstablishSshKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** Establish a key even if one is already set */
  override?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of EstablishSSHKey */
export type EstablishSshKeyPayload = {
  __typename?: 'EstablishSSHKeyPayload';
  certificate: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ExportDNSZone */
export type ExportDnsZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the domain to export */
  domainId: Scalars['ID'];
};

/** Autogenerated return type of ExportDNSZone */
export type ExportDnsZonePayload = {
  __typename?: 'ExportDNSZonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contents: Scalars['String'];
  domain: Domain;
};

/** Autogenerated input type of ExtendVolume */
export type ExtendVolumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The target volume size */
  sizeGb: Scalars['Int'];
  /** The node ID of the volume */
  volumeId: Scalars['ID'];
};

/** Autogenerated return type of ExtendVolume */
export type ExtendVolumePayload = {
  __typename?: 'ExtendVolumePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  volume: Volume;
};

/** Autogenerated input type of FinishBuild */
export type FinishBuildInput = {
  /** The name of the app being built */
  appName: Scalars['ID'];
  /** Build id returned by createBuild() mutation */
  buildId: Scalars['ID'];
  /** Metadata about the builder */
  builderMeta?: InputMaybe<BuilderMetaInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Information about the docker image that was built */
  finalImage?: InputMaybe<BuildFinalImageInput>;
  /** Log or error output */
  logs?: InputMaybe<Scalars['String']>;
  /** The ID of the machine being built (only set for machine builds) */
  machineId?: InputMaybe<Scalars['ID']>;
  /** Indicate whether build completed or failed */
  status: Scalars['String'];
  /** Build strategies attempted and their result, should be in order of attempt */
  strategiesAttempted?: InputMaybe<Array<BuildStrategyAttemptInput>>;
  /** Timings for different phases of the build */
  timings?: InputMaybe<BuildTimingsInput>;
};

/** Autogenerated return type of FinishBuild */
export type FinishBuildPayload = {
  __typename?: 'FinishBuildPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** build id */
  id: Scalars['ID'];
  /** stored build status */
  status: Scalars['String'];
  /** wall clock time for this build */
  wallclockTimeMs: Scalars['Int'];
};

export type FlyPlatform = {
  __typename?: 'FlyPlatform';
  /** Latest flyctl release details */
  flyctl: FlyctlRelease;
  /** Fly global regions */
  regions: Array<Region>;
  /** Region current request from */
  requestRegion?: Maybe<Scalars['String']>;
  /** Available VM sizes */
  vmSizes: Array<VmSize>;
};

export type FlyctlMachineHostAppRole = AppRole & {
  __typename?: 'FlyctlMachineHostAppRole';
  /** The name of this role */
  name: Scalars['String'];
};

export type FlyctlRelease = {
  __typename?: 'FlyctlRelease';
  timestamp: Scalars['ISO8601DateTime'];
  version: Scalars['String'];
};

export type GithubAppInstallation = {
  __typename?: 'GithubAppInstallation';
  editUrl: Scalars['String'];
  id: Scalars['ID'];
  owner: Scalars['String'];
  repositories: Array<GithubRepository>;
};

export type GithubIntegration = {
  __typename?: 'GithubIntegration';
  installationUrl: Scalars['String'];
  installations: Array<GithubAppInstallation>;
  viewerAuthenticated: Scalars['Boolean'];
};

export type GithubRepository = {
  __typename?: 'GithubRepository';
  fork: Scalars['Boolean'];
  fullName: Scalars['String'];
  id: Scalars['String'];
  name: Scalars['String'];
  private: Scalars['Boolean'];
};

/** Autogenerated input type of GrantPostgresClusterUserAccess */
export type GrantPostgresClusterUserAccessInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The database to grant access to */
  databaseName: Scalars['String'];
  /** The name of the database */
  username: Scalars['String'];
};

/** Autogenerated return type of GrantPostgresClusterUserAccess */
export type GrantPostgresClusterUserAccessPayload = {
  __typename?: 'GrantPostgresClusterUserAccessPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  database: PostgresClusterDatabase;
  postgresClusterRole: PostgresClusterAppRole;
  user: PostgresClusterUser;
};

export enum HttpMethod {
  Delete = 'DELETE',
  Get = 'GET',
  Head = 'HEAD',
  Patch = 'PATCH',
  Post = 'POST',
  Put = 'PUT'
}

export enum HttpProtocol {
  /** HTTP protocol */
  Http = 'HTTP',
  /** HTTPS protocol */
  Https = 'HTTPS'
}

export type HealthCheck = {
  __typename?: 'HealthCheck';
  /** Raw name of entity */
  entity: Scalars['String'];
  /** Time check last passed */
  lastPassing?: Maybe<Scalars['ISO8601DateTime']>;
  /** Check name */
  name: Scalars['String'];
  /** Latest check output */
  output?: Maybe<Scalars['String']>;
  /** Current check state */
  state: Scalars['String'];
};

/** The connection type for HealthCheck. */
export type HealthCheckConnection = {
  __typename?: 'HealthCheckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HealthCheckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<HealthCheck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type HealthCheckEdge = {
  __typename?: 'HealthCheckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<HealthCheck>;
};

export type HealthCheckHandler = {
  __typename?: 'HealthCheckHandler';
  /** Handler name */
  name: Scalars['String'];
  /** Handler type (Slack or Pagerduty) */
  type: Scalars['String'];
};

/** The connection type for HealthCheckHandler. */
export type HealthCheckHandlerConnection = {
  __typename?: 'HealthCheckHandlerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HealthCheckHandlerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<HealthCheckHandler>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type HealthCheckHandlerEdge = {
  __typename?: 'HealthCheckHandlerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<HealthCheckHandler>;
};

export type HerokuApp = {
  __typename?: 'HerokuApp';
  id: Scalars['String'];
  name: Scalars['String'];
  region?: Maybe<Scalars['String']>;
  releasedAt: Scalars['ISO8601DateTime'];
  stack?: Maybe<Scalars['String']>;
  teamName?: Maybe<Scalars['String']>;
};

export type HerokuIntegration = {
  __typename?: 'HerokuIntegration';
  herokuApps: Array<HerokuApp>;
  viewerAuthenticated: Scalars['Boolean'];
};

export type Host = Node & {
  __typename?: 'Host';
  id: Scalars['ID'];
};

export type HostnameCheck = {
  __typename?: 'HostnameCheck';
  aRecords: Array<Scalars['String']>;
  aaaaRecords: Array<Scalars['String']>;
  acmeDnsConfigured: Scalars['Boolean'];
  caaRecords: Array<Scalars['String']>;
  cnameRecords: Array<Scalars['String']>;
  dnsConfigured: Scalars['Boolean'];
  dnsProvider?: Maybe<Scalars['String']>;
  dnsVerificationRecord?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Scalars['String']>>;
  id: Scalars['ID'];
  isProxied: Scalars['Boolean'];
  resolvedAddresses: Array<Scalars['String']>;
  soa?: Maybe<Scalars['String']>;
};

export type IpAddress = Node & {
  __typename?: 'IPAddress';
  address: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  region?: Maybe<Scalars['String']>;
  type: IpAddressType;
};

/** The connection type for IPAddress. */
export type IpAddressConnection = {
  __typename?: 'IPAddressConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IpAddressEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IpAddress>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type IpAddressEdge = {
  __typename?: 'IPAddressEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IpAddress>;
};

export enum IpAddressType {
  PrivateV6 = 'private_v6',
  V4 = 'v4',
  V6 = 'v6'
}

export type Image = {
  __typename?: 'Image';
  absoluteRef: Scalars['String'];
  compressedSize: Scalars['Int'];
  config: Scalars['JSON'];
  configDigest: Scalars['JSON'];
  createdAt: Scalars['ISO8601DateTime'];
  digest: Scalars['String'];
  id: Scalars['ID'];
  label: Scalars['String'];
  manifest: Scalars['JSON'];
  ref: Scalars['String'];
  registry: Scalars['String'];
  repository: Scalars['String'];
  tag?: Maybe<Scalars['String']>;
};

export type ImageVersion = {
  __typename?: 'ImageVersion';
  digest: Scalars['String'];
  registry: Scalars['String'];
  repository: Scalars['String'];
  tag: Scalars['String'];
  version?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ImportCertificate */
export type ImportCertificatePayload = {
  __typename?: 'ImportCertificatePayload';
  app?: Maybe<App>;
  appCertificate?: Maybe<AppCertificate>;
  certificate?: Maybe<Certificate>;
  errors?: Maybe<Array<Scalars['String']>>;
};

/** Autogenerated input type of ImportDNSZone */
export type ImportDnsZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the domain to export */
  domainId: Scalars['ID'];
  zonefile: Scalars['String'];
};

/** Autogenerated return type of ImportDNSZone */
export type ImportDnsZonePayload = {
  __typename?: 'ImportDNSZonePayload';
  changes: Array<DnsRecordDiff>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
  warnings: Array<DnsRecordWarning>;
};

/** Autogenerated input type of IssueCertificate */
export type IssueCertificateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Email address of user to be issued certificate */
  email: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** Comma-separated list of SSH principals for certificate */
  principals?: InputMaybe<Scalars['String']>;
  /** Unix username valid for certificate */
  username?: InputMaybe<Scalars['String']>;
  /** Hours for which certificate will be valid */
  validHours?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of IssueCertificate */
export type IssueCertificatePayload = {
  __typename?: 'IssueCertificatePayload';
  certificate: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  key: Scalars['String'];
};

/** Autogenerated input type of KillMachine */
export type KillMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** machine id */
  id: Scalars['String'];
};

/** Autogenerated return type of KillMachine */
export type KillMachinePayload = {
  __typename?: 'KillMachinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  machine: Machine;
};

/** Autogenerated input type of LaunchApp */
export type LaunchAppInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Configuration */
  config?: InputMaybe<Scalars['JSON']>;
  /** Number of instances to run */
  count?: InputMaybe<Scalars['Int']>;
  /** Docker image to launch */
  image: Scalars['String'];
  /** App name to create */
  name?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** Regions to launch your app to */
  regions?: InputMaybe<Array<Scalars['String']>>;
  /** Type of scheduling for this app */
  scheduling?: InputMaybe<SchedulingEnum>;
  /** Secrets to set */
  secrets?: InputMaybe<Array<SecretInput>>;
  /** Size of VM for your app */
  vmSize?: InputMaybe<VmSizeEnum>;
  /** Volumes to create */
  volumes?: InputMaybe<Array<VolumeInput>>;
};

/** Autogenerated return type of LaunchApp */
export type LaunchAppPayload = {
  __typename?: 'LaunchAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  release?: Maybe<Release>;
};

/** Autogenerated input type of LaunchMachine */
export type LaunchMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Configuration */
  config: Scalars['JSON'];
  /** The ID of the machine */
  id?: InputMaybe<Scalars['String']>;
  /** The name of the machine */
  name?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId?: InputMaybe<Scalars['ID']>;
  /** Region for the machine */
  region?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of LaunchMachine */
export type LaunchMachinePayload = {
  __typename?: 'LaunchMachinePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  machine: Machine;
};

export type LimitedAccessToken = Node & {
  __typename?: 'LimitedAccessToken';
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type LogEntry = {
  __typename?: 'LogEntry';
  id: Scalars['String'];
  instanceId: Scalars['String'];
  level: Scalars['String'];
  message: Scalars['String'];
  region: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
};

export type LoggedCertificate = Node & {
  __typename?: 'LoggedCertificate';
  cert: Scalars['String'];
  id: Scalars['ID'];
  root: Scalars['Boolean'];
};

/** The connection type for LoggedCertificate. */
export type LoggedCertificateConnection = {
  __typename?: 'LoggedCertificateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LoggedCertificateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LoggedCertificate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LoggedCertificateEdge = {
  __typename?: 'LoggedCertificateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<LoggedCertificate>;
};

export type Machine = Node & {
  __typename?: 'Machine';
  app: App;
  config: Scalars['JSON'];
  createdAt: Scalars['ISO8601DateTime'];
  events: MachineEventConnection;
  host: Host;
  id: Scalars['ID'];
  instanceId: Scalars['String'];
  ips: MachineIpConnection;
  name: Scalars['String'];
  region: Scalars['String'];
  state: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};


export type MachineEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  kind?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MachineIpsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Machine. */
export type MachineConnection = {
  __typename?: 'MachineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MachineEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Machine>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MachineEdge = {
  __typename?: 'MachineEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Machine>;
};

/** A machine state change event */
export type MachineEvent = {
  id: Scalars['ID'];
  kind: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
};

/** The connection type for MachineEvent. */
export type MachineEventConnection = {
  __typename?: 'MachineEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MachineEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MachineEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type MachineEventDestroy = MachineEvent & {
  __typename?: 'MachineEventDestroy';
  id: Scalars['ID'];
  kind: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
};

/** An edge in a connection. */
export type MachineEventEdge = {
  __typename?: 'MachineEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MachineEvent>;
};

export type MachineEventExit = MachineEvent & {
  __typename?: 'MachineEventExit';
  exitCode: Scalars['Int'];
  id: Scalars['ID'];
  kind: Scalars['String'];
  metadata: Scalars['JSON'];
  oomKilled: Scalars['Boolean'];
  requestedStop: Scalars['Boolean'];
  timestamp: Scalars['ISO8601DateTime'];
};

export type MachineEventGeneric = MachineEvent & {
  __typename?: 'MachineEventGeneric';
  id: Scalars['ID'];
  kind: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
};

export type MachineEventStart = MachineEvent & {
  __typename?: 'MachineEventStart';
  id: Scalars['ID'];
  kind: Scalars['String'];
  timestamp: Scalars['ISO8601DateTime'];
};

export type MachineIp = Node & {
  __typename?: 'MachineIP';
  family: Scalars['String'];
  /** ID of the object. */
  id: Scalars['ID'];
  ip: Scalars['String'];
  kind: Scalars['String'];
  maskSize: Scalars['Int'];
};

/** The connection type for MachineIP. */
export type MachineIpConnection = {
  __typename?: 'MachineIPConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MachineIpEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MachineIp>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MachineIpEdge = {
  __typename?: 'MachineIPEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MachineIp>;
};

/** Autogenerated input type of MoveApp */
export type MoveAppInput = {
  /** The application to move */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization to move the app to */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of MoveApp */
export type MoveAppPayload = {
  __typename?: 'MoveAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export type Mutations = {
  __typename?: 'Mutations';
  addCertificate?: Maybe<AddCertificatePayload>;
  addWireGuardPeer?: Maybe<AddWireGuardPeerPayload>;
  allocateIpAddress?: Maybe<AllocateIpAddressPayload>;
  attachPostgresCluster?: Maybe<AttachPostgresClusterPayload>;
  cancelBuild?: Maybe<CancelBuildPayload>;
  checkCertificate?: Maybe<CheckCertificatePayload>;
  checkDomain?: Maybe<CheckDomainPayload>;
  configureRegions?: Maybe<ConfigureRegionsPayload>;
  createAddOn?: Maybe<CreateAddOnPayload>;
  createAndRegisterDomain?: Maybe<CreateAndRegisterDomainPayload>;
  createAndTransferDomain?: Maybe<CreateAndTransferDomainPayload>;
  createApp?: Maybe<CreateAppPayload>;
  createBuild?: Maybe<CreateBuildPayload>;
  createCheckJob?: Maybe<CreateCheckJobPayload>;
  createCheckJobRun?: Maybe<CreateCheckJobRunPayload>;
  createDelegatedWireGuardToken?: Maybe<CreateDelegatedWireGuardTokenPayload>;
  createDnsPortal?: Maybe<CreateDnsPortalPayload>;
  createDnsPortalSession?: Maybe<CreateDnsPortalSessionPayload>;
  createDnsRecord?: Maybe<CreateDnsRecordPayload>;
  createDoctorReport?: Maybe<CreateDoctorReportPayload>;
  createDoctorUrl?: Maybe<CreateDoctorUrlPayload>;
  createDomain?: Maybe<CreateDomainPayload>;
  createOrganization?: Maybe<CreateOrganizationPayload>;
  createOrganizationInvitation?: Maybe<CreateOrganizationInvitationPayload>;
  createPostgresCluster?: Maybe<CreatePostgresClusterPayload>;
  createPostgresClusterDatabase?: Maybe<CreatePostgresClusterDatabasePayload>;
  createPostgresClusterUser?: Maybe<CreatePostgresClusterUserPayload>;
  createTemplateDeployment?: Maybe<CreateTemplateDeploymentPayload>;
  createVolume?: Maybe<CreateVolumePayload>;
  createVolumeSnapshot?: Maybe<CreateVolumeSnapshotPayload>;
  deleteAddOn?: Maybe<DeleteAddOnPayload>;
  /** Delete an app */
  deleteApp?: Maybe<DeleteAppPayload>;
  deleteCertificate?: Maybe<DeleteCertificatePayload>;
  deleteDelegatedWireGuardToken?: Maybe<DeleteDelegatedWireGuardTokenPayload>;
  deleteDeploymentSource?: Maybe<DeleteDeploymentSourcePayload>;
  deleteDnsPortal?: Maybe<DeleteDnsPortalPayload>;
  deleteDnsPortalSession?: Maybe<DeleteDnsPortalSessionPayload>;
  deleteDnsRecord?: Maybe<DeleteDnsRecordPayload>;
  deleteDomain?: Maybe<DeleteDomainPayload>;
  deleteHealthCheckHandler?: Maybe<DeleteHealthCheckHandlerPayload>;
  deleteOrganization?: Maybe<DeleteOrganizationPayload>;
  deleteOrganizationInvitation?: Maybe<DeleteOrganizationInvitationPayload>;
  deleteOrganizationMembership?: Maybe<DeleteOrganizationMembershipPayload>;
  deleteRemoteBuilder?: Maybe<DeleteRemoteBuilderPayload>;
  deleteVolume?: Maybe<DeleteVolumePayload>;
  deployImage?: Maybe<DeployImagePayload>;
  detachPostgresCluster?: Maybe<DetachPostgresClusterPayload>;
  dummyWireGuardPeer?: Maybe<DummyWireGuardPeerPayload>;
  enablePostgresConsul?: Maybe<EnablePostgresConsulPayload>;
  ensureMachineRemoteBuilder?: Maybe<EnsureMachineRemoteBuilderPayload>;
  establishSshKey?: Maybe<EstablishSshKeyPayload>;
  exportDnsZone?: Maybe<ExportDnsZonePayload>;
  extendVolume?: Maybe<ExtendVolumePayload>;
  finishBuild?: Maybe<FinishBuildPayload>;
  grantPostgresClusterUserAccess?: Maybe<GrantPostgresClusterUserAccessPayload>;
  importCertificate?: Maybe<ImportCertificatePayload>;
  importDnsZone?: Maybe<ImportDnsZonePayload>;
  issueCertificate?: Maybe<IssueCertificatePayload>;
  killMachine?: Maybe<KillMachinePayload>;
  launchApp?: Maybe<LaunchAppPayload>;
  launchMachine?: Maybe<LaunchMachinePayload>;
  moveApp?: Maybe<MoveAppPayload>;
  pauseApp?: Maybe<PauseAppPayload>;
  registerDomain?: Maybe<RegisterDomainPayload>;
  releaseIpAddress?: Maybe<ReleaseIpAddressPayload>;
  removeMachine?: Maybe<RemoveMachinePayload>;
  removeWireGuardPeer?: Maybe<RemoveWireGuardPeerPayload>;
  resetAddOnPassword?: Maybe<ResetAddOnPasswordPayload>;
  restartAllocation?: Maybe<RestartAllocationPayload>;
  restartApp?: Maybe<RestartAppPayload>;
  restoreVolumeSnapshot?: Maybe<RestoreVolumeSnapshotPayload>;
  resumeApp?: Maybe<ResumeAppPayload>;
  revokePostgresClusterUserAccess?: Maybe<RevokePostgresClusterUserAccessPayload>;
  saveDeploymentSource?: Maybe<SaveDeploymentSourcePayload>;
  scaleApp?: Maybe<ScaleAppPayload>;
  setPagerdutyHandler?: Maybe<SetPagerdutyHandlerPayload>;
  setSecrets?: Maybe<SetSecretsPayload>;
  setSlackHandler?: Maybe<SetSlackHandlerPayload>;
  setVmCount?: Maybe<SetVmCountPayload>;
  setVmSize?: Maybe<SetVmSizePayload>;
  startBuild?: Maybe<StartBuildPayload>;
  startMachine?: Maybe<StartMachinePayload>;
  stopAllocation?: Maybe<StopAllocationPayload>;
  stopMachine?: Maybe<StopMachinePayload>;
  unsetSecrets?: Maybe<UnsetSecretsPayload>;
  updateAddOn?: Maybe<UpdateAddOnPayload>;
  updateAutoscaleConfig?: Maybe<UpdateAutoscaleConfigPayload>;
  updateDnsPortal?: Maybe<UpdateDnsPortalPayload>;
  updateDnsRecord?: Maybe<UpdateDnsRecordPayload>;
  updateDnsRecords?: Maybe<UpdateDnsRecordsPayload>;
  updateOrganizationMembership?: Maybe<UpdateOrganizationMembershipPayload>;
  updateRemoteBuilder?: Maybe<UpdateRemoteBuilderPayload>;
  validateWireGuardPeers?: Maybe<ValidateWireGuardPeersPayload>;
};


export type MutationsAddCertificateArgs = {
  appId: Scalars['ID'];
  hostname: Scalars['String'];
};


export type MutationsAddWireGuardPeerArgs = {
  input: AddWireGuardPeerInput;
};


export type MutationsAllocateIpAddressArgs = {
  input: AllocateIpAddressInput;
};


export type MutationsAttachPostgresClusterArgs = {
  input: AttachPostgresClusterInput;
};


export type MutationsCancelBuildArgs = {
  buildId: Scalars['ID'];
};


export type MutationsCheckCertificateArgs = {
  input: CheckCertificateInput;
};


export type MutationsCheckDomainArgs = {
  input: CheckDomainInput;
};


export type MutationsConfigureRegionsArgs = {
  input: ConfigureRegionsInput;
};


export type MutationsCreateAddOnArgs = {
  input: CreateAddOnInput;
};


export type MutationsCreateAndRegisterDomainArgs = {
  input: CreateAndRegisterDomainInput;
};


export type MutationsCreateAndTransferDomainArgs = {
  input: CreateAndTransferDomainInput;
};


export type MutationsCreateAppArgs = {
  input: CreateAppInput;
};


export type MutationsCreateBuildArgs = {
  input: CreateBuildInput;
};


export type MutationsCreateCheckJobArgs = {
  input: CreateCheckJobInput;
};


export type MutationsCreateCheckJobRunArgs = {
  input: CreateCheckJobRunInput;
};


export type MutationsCreateDelegatedWireGuardTokenArgs = {
  input: CreateDelegatedWireGuardTokenInput;
};


export type MutationsCreateDnsPortalArgs = {
  input: CreateDnsPortalInput;
};


export type MutationsCreateDnsPortalSessionArgs = {
  input: CreateDnsPortalSessionInput;
};


export type MutationsCreateDnsRecordArgs = {
  input: CreateDnsRecordInput;
};


export type MutationsCreateDoctorReportArgs = {
  input: CreateDoctorReportInput;
};


export type MutationsCreateDomainArgs = {
  input: CreateDomainInput;
};


export type MutationsCreateOrganizationArgs = {
  input: CreateOrganizationInput;
};


export type MutationsCreateOrganizationInvitationArgs = {
  input: CreateOrganizationInvitationInput;
};


export type MutationsCreatePostgresClusterArgs = {
  input: CreatePostgresClusterInput;
};


export type MutationsCreatePostgresClusterDatabaseArgs = {
  input: CreatePostgresClusterDatabaseInput;
};


export type MutationsCreatePostgresClusterUserArgs = {
  input: CreatePostgresClusterUserInput;
};


export type MutationsCreateTemplateDeploymentArgs = {
  input: CreateTemplateDeploymentInput;
};


export type MutationsCreateVolumeArgs = {
  input: CreateVolumeInput;
};


export type MutationsCreateVolumeSnapshotArgs = {
  input: CreateVolumeSnapshotInput;
};


export type MutationsDeleteAddOnArgs = {
  input: DeleteAddOnInput;
};


export type MutationsDeleteAppArgs = {
  appId: Scalars['ID'];
};


export type MutationsDeleteCertificateArgs = {
  appId: Scalars['ID'];
  hostname: Scalars['String'];
};


export type MutationsDeleteDelegatedWireGuardTokenArgs = {
  input: DeleteDelegatedWireGuardTokenInput;
};


export type MutationsDeleteDeploymentSourceArgs = {
  input: DeleteDeploymentSourceInput;
};


export type MutationsDeleteDnsPortalArgs = {
  input: DeleteDnsPortalInput;
};


export type MutationsDeleteDnsPortalSessionArgs = {
  input: DeleteDnsPortalSessionInput;
};


export type MutationsDeleteDnsRecordArgs = {
  input: DeleteDnsRecordInput;
};


export type MutationsDeleteDomainArgs = {
  input: DeleteDomainInput;
};


export type MutationsDeleteHealthCheckHandlerArgs = {
  input: DeleteHealthCheckHandlerInput;
};


export type MutationsDeleteOrganizationArgs = {
  input: DeleteOrganizationInput;
};


export type MutationsDeleteOrganizationInvitationArgs = {
  input: DeleteOrganizationInvitationInput;
};


export type MutationsDeleteOrganizationMembershipArgs = {
  input: DeleteOrganizationMembershipInput;
};


export type MutationsDeleteRemoteBuilderArgs = {
  input: DeleteRemoteBuilderInput;
};


export type MutationsDeleteVolumeArgs = {
  input: DeleteVolumeInput;
};


export type MutationsDeployImageArgs = {
  input: DeployImageInput;
};


export type MutationsDetachPostgresClusterArgs = {
  input: DetachPostgresClusterInput;
};


export type MutationsDummyWireGuardPeerArgs = {
  input: DummyWireGuardPeerInput;
};


export type MutationsEnablePostgresConsulArgs = {
  input: EnablePostgresConsulInput;
};


export type MutationsEnsureMachineRemoteBuilderArgs = {
  input: EnsureMachineRemoteBuilderInput;
};


export type MutationsEstablishSshKeyArgs = {
  input: EstablishSshKeyInput;
};


export type MutationsExportDnsZoneArgs = {
  input: ExportDnsZoneInput;
};


export type MutationsExtendVolumeArgs = {
  input: ExtendVolumeInput;
};


export type MutationsFinishBuildArgs = {
  input: FinishBuildInput;
};


export type MutationsGrantPostgresClusterUserAccessArgs = {
  input: GrantPostgresClusterUserAccessInput;
};


export type MutationsImportCertificateArgs = {
  appId: Scalars['ID'];
  fullchain: Scalars['String'];
  hostname?: InputMaybe<Scalars['String']>;
  privateKey: Scalars['String'];
};


export type MutationsImportDnsZoneArgs = {
  input: ImportDnsZoneInput;
};


export type MutationsIssueCertificateArgs = {
  input: IssueCertificateInput;
};


export type MutationsKillMachineArgs = {
  input: KillMachineInput;
};


export type MutationsLaunchAppArgs = {
  input: LaunchAppInput;
};


export type MutationsLaunchMachineArgs = {
  input: LaunchMachineInput;
};


export type MutationsMoveAppArgs = {
  input: MoveAppInput;
};


export type MutationsPauseAppArgs = {
  input: PauseAppInput;
};


export type MutationsRegisterDomainArgs = {
  input: RegisterDomainInput;
};


export type MutationsReleaseIpAddressArgs = {
  input: ReleaseIpAddressInput;
};


export type MutationsRemoveMachineArgs = {
  input: RemoveMachineInput;
};


export type MutationsRemoveWireGuardPeerArgs = {
  input: RemoveWireGuardPeerInput;
};


export type MutationsResetAddOnPasswordArgs = {
  input: ResetAddOnPasswordInput;
};


export type MutationsRestartAllocationArgs = {
  input: RestartAllocationInput;
};


export type MutationsRestartAppArgs = {
  input: RestartAppInput;
};


export type MutationsRestoreVolumeSnapshotArgs = {
  input: RestoreVolumeSnapshotInput;
};


export type MutationsResumeAppArgs = {
  input: ResumeAppInput;
};


export type MutationsRevokePostgresClusterUserAccessArgs = {
  input: RevokePostgresClusterUserAccessInput;
};


export type MutationsSaveDeploymentSourceArgs = {
  input: SaveDeploymentSourceInput;
};


export type MutationsScaleAppArgs = {
  input: ScaleAppInput;
};


export type MutationsSetPagerdutyHandlerArgs = {
  input: SetPagerdutyHandlerInput;
};


export type MutationsSetSecretsArgs = {
  input: SetSecretsInput;
};


export type MutationsSetSlackHandlerArgs = {
  input: SetSlackHandlerInput;
};


export type MutationsSetVmCountArgs = {
  input: SetVmCountInput;
};


export type MutationsSetVmSizeArgs = {
  input: SetVmSizeInput;
};


export type MutationsStartBuildArgs = {
  input: StartBuildInput;
};


export type MutationsStartMachineArgs = {
  input: StartMachineInput;
};


export type MutationsStopAllocationArgs = {
  input: StopAllocationInput;
};


export type MutationsStopMachineArgs = {
  input: StopMachineInput;
};


export type MutationsUnsetSecretsArgs = {
  input: UnsetSecretsInput;
};


export type MutationsUpdateAddOnArgs = {
  input: UpdateAddOnInput;
};


export type MutationsUpdateAutoscaleConfigArgs = {
  input: UpdateAutoscaleConfigInput;
};


export type MutationsUpdateDnsPortalArgs = {
  input: UpdateDnsPortalInput;
};


export type MutationsUpdateDnsRecordArgs = {
  input: UpdateDnsRecordInput;
};


export type MutationsUpdateDnsRecordsArgs = {
  input: UpdateDnsRecordsInput;
};


export type MutationsUpdateOrganizationMembershipArgs = {
  input: UpdateOrganizationMembershipInput;
};


export type MutationsUpdateRemoteBuilderArgs = {
  input: UpdateRemoteBuilderInput;
};


export type MutationsValidateWireGuardPeersArgs = {
  input: ValidateWireGuardPeersInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

export type Organization = Node & {
  __typename?: 'Organization';
  activeDiscountName?: Maybe<Scalars['String']>;
  /** Single sign-on link for the given integration type */
  addOnSsoLink: Scalars['String'];
  /** List third party integrations associated with an organization */
  addOns: AddOnConnection;
  apps: AppConnection;
  billables: BillableConnection;
  billingStatus: BillingStatus;
  /** The account credits in cents */
  creditBalance: Scalars['Int'];
  /** The formatted account credits */
  creditBalanceFormatted: Scalars['String'];
  delegatedWireGuardTokens: DelegatedWireGuardTokenConnection;
  /** Find a dns portal by name */
  dnsPortal: DnsPortal;
  dnsPortals: DnsPortalConnection;
  /** Find a domain by name */
  domain?: Maybe<Domain>;
  domains: DomainConnection;
  healthCheckHandlers: HealthCheckHandlerConnection;
  healthChecks: HealthCheckConnection;
  id: Scalars['ID'];
  internalNumericId: Scalars['BigInt'];
  invitations: OrganizationInvitationConnection;
  isCreditCardSaved: Scalars['Boolean'];
  loggedCertificates?: Maybe<LoggedCertificateConnection>;
  members: OrganizationMembershipsConnection;
  /** Organization name */
  name: Scalars['String'];
  remoteBuilderApp?: Maybe<App>;
  remoteBuilderImage: Scalars['String'];
  settings?: Maybe<Scalars['JSON']>;
  /** Unique organization slug */
  slug: Scalars['String'];
  sshCertificate?: Maybe<Scalars['String']>;
  trust: OrganizationTrust;
  /** The type of organization */
  type: OrganizationType;
  /** The current user's role in the org */
  viewerRole: Scalars['String'];
  /** Find a peer by name */
  wireGuardPeer: WireGuardPeer;
  wireGuardPeers: WireGuardPeerConnection;
};


export type OrganizationAddOnsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<AddOnType>;
};


export type OrganizationAppsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationBillablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  appId?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['String']>;
  endDate: Scalars['ISO8601DateTime'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startDate: Scalars['ISO8601DateTime'];
};


export type OrganizationDelegatedWireGuardTokensArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationDnsPortalArgs = {
  name: Scalars['String'];
};


export type OrganizationDnsPortalsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationDomainArgs = {
  name: Scalars['String'];
};


export type OrganizationDomainsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationHealthCheckHandlersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationHealthChecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationLoggedCertificatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type OrganizationWireGuardPeerArgs = {
  name: Scalars['String'];
};


export type OrganizationWireGuardPeersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Organization. */
export type OrganizationConnection = {
  __typename?: 'OrganizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename?: 'OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

export type OrganizationInvitation = Node & {
  __typename?: 'OrganizationInvitation';
  createdAt: Scalars['ISO8601DateTime'];
  email: Scalars['String'];
  id: Scalars['ID'];
  /** The user who created the invitation */
  inviter: User;
  organization: Organization;
  redeemed: Scalars['Boolean'];
  redeemedAt?: Maybe<Scalars['ISO8601DateTime']>;
};

/** The connection type for OrganizationInvitation. */
export type OrganizationInvitationConnection = {
  __typename?: 'OrganizationInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type OrganizationInvitationEdge = {
  __typename?: 'OrganizationInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

export enum OrganizationMemberRole {
  /** The user is an administrator of the organization */
  Admin = 'ADMIN',
  /** The user is a member of the organization */
  Member = 'MEMBER'
}

/** The connection type for User. */
export type OrganizationMembershipsConnection = {
  __typename?: 'OrganizationMembershipsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationMembershipsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type OrganizationMembershipsEdge = {
  __typename?: 'OrganizationMembershipsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The date the user joined the organization */
  joinedAt: Scalars['ISO8601DateTime'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role the user has in this organization */
  role: OrganizationMemberRole;
};

export enum OrganizationTrust {
  /** Organization cannot use our services */
  Banned = 'BANNED',
  /** Organization proved that it's safe to use our services */
  High = 'HIGH',
  /** Organization has to prove that is not fraud over time but can use our services */
  Low = 'LOW',
  /** Organization has limited access to our service */
  Restricted = 'RESTRICTED',
  /** We haven't set a trust level yet */
  Unknown = 'UNKNOWN'
}

export enum OrganizationType {
  /** A user's personal organization */
  Personal = 'PERSONAL',
  /** An organization shared between one or more users */
  Shared = 'SHARED'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of PauseApp */
export type PauseAppInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PauseApp */
export type PauseAppPayload = {
  __typename?: 'PauseAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export enum PlatformVersionEnum {
  /** App with only machines */
  Machines = 'machines',
  /** Nomad managed application */
  Nomad = 'nomad'
}

export type PostgresClusterAppRole = AppRole & {
  __typename?: 'PostgresClusterAppRole';
  databases: Array<PostgresClusterDatabase>;
  /** The name of this role */
  name: Scalars['String'];
  users: Array<PostgresClusterUser>;
};

export type PostgresClusterAttachment = Node & {
  __typename?: 'PostgresClusterAttachment';
  databaseName: Scalars['String'];
  databaseUser: Scalars['String'];
  environmentVariableName: Scalars['String'];
  id: Scalars['ID'];
};

/** The connection type for PostgresClusterAttachment. */
export type PostgresClusterAttachmentConnection = {
  __typename?: 'PostgresClusterAttachmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostgresClusterAttachmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PostgresClusterAttachment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PostgresClusterAttachmentEdge = {
  __typename?: 'PostgresClusterAttachmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PostgresClusterAttachment>;
};

export type PostgresClusterDatabase = {
  __typename?: 'PostgresClusterDatabase';
  name: Scalars['String'];
  users: Array<Scalars['String']>;
};

export type PostgresClusterUser = {
  __typename?: 'PostgresClusterUser';
  databases: Array<Scalars['String']>;
  isSuperuser: Scalars['Boolean'];
  username: Scalars['String'];
};

export type PriceTier = {
  __typename?: 'PriceTier';
  unitAmount?: Maybe<Scalars['String']>;
  upTo?: Maybe<Scalars['BigInt']>;
};

export type ProcessGroup = {
  __typename?: 'ProcessGroup';
  maxPerRegion: Scalars['Int'];
  name: Scalars['String'];
  regions: Array<Scalars['String']>;
  vmSize: VmSize;
};

export type Product = {
  __typename?: 'Product';
  name: Scalars['String'];
  tiers: Array<PriceTier>;
  type: Scalars['String'];
  unitLabel?: Maybe<Scalars['String']>;
};

export type PropertyInput = {
  /** The name of the property */
  name: Scalars['String'];
  /** The value of the property */
  value?: InputMaybe<Scalars['String']>;
};

export type Queries = {
  __typename?: 'Queries';
  /** Find an add-on by ID or name */
  addOn?: Maybe<AddOn>;
  /** List add-on service plans */
  addOnPlans: AddOnPlanConnection;
  addOnProvider: AddOnProvider;
  /** List add-ons associated with an organization */
  addOns: AddOnConnection;
  /** Find an app by name */
  app?: Maybe<App>;
  /** List apps */
  apps: AppConnection;
  /** Find a certificate by ID */
  certificate?: Maybe<AppCertificate>;
  checkJobs: CheckJobConnection;
  checkLocations: Array<CheckLocation>;
  /** @deprecated use viewer instead */
  currentUser: User;
  /** Find a domain by name */
  domain?: Maybe<Domain>;
  /** @deprecated deprecated */
  githubIntegration: GithubIntegration;
  herokuIntegration: HerokuIntegration;
  /** Find an ip address by ID */
  ipAddress?: Maybe<IpAddress>;
  /** Returns the latest available tag for a given image repository */
  latestImageDetails: ImageVersion;
  /** Returns the latest available tag for a given image repository */
  latestImageTag: Scalars['String'];
  /** Get a single machine */
  machine: Machine;
  /** List machines */
  machines: MachineConnection;
  nearestRegion: Region;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /** Find an organization by ID */
  organization?: Maybe<Organization>;
  organizations: OrganizationConnection;
  personalOrganization: Organization;
  /** fly.io platform information */
  platform: FlyPlatform;
  /** List postgres attachments */
  postgresAttachments: PostgresClusterAttachmentConnection;
  /** Fly.io product and price information */
  products: Array<Product>;
  viewer: User;
  /** Find a persistent volume by ID */
  volume?: Maybe<Volume>;
};


export type QueriesAddOnArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};


export type QueriesAddOnPlansArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueriesAddOnProviderArgs = {
  name: Scalars['String'];
};


export type QueriesAddOnsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<AddOnType>;
};


export type QueriesAppArgs = {
  internalId?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};


export type QueriesAppsArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  platform?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Scalars['String']>;
};


export type QueriesCertificateArgs = {
  id: Scalars['ID'];
};


export type QueriesCheckJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueriesDomainArgs = {
  name: Scalars['String'];
};


export type QueriesIpAddressArgs = {
  id: Scalars['ID'];
};


export type QueriesLatestImageDetailsArgs = {
  image: Scalars['String'];
};


export type QueriesLatestImageTagArgs = {
  repository: Scalars['String'];
  snapshotId?: InputMaybe<Scalars['ID']>;
};


export type QueriesMachineArgs = {
  machineId: Scalars['String'];
};


export type QueriesMachinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  appId?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['Int']>;
};


export type QueriesNearestRegionArgs = {
  wireguardGateway?: InputMaybe<Scalars['Boolean']>;
};


export type QueriesNodeArgs = {
  id: Scalars['ID'];
};


export type QueriesNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueriesOrganizationArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueriesOrganizationsArgs = {
  admin?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<OrganizationType>;
  withBillingIssuesOnly?: InputMaybe<Scalars['Boolean']>;
};


export type QueriesPostgresAttachmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  appName: Scalars['String'];
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  postgresAppName: Scalars['String'];
};


export type QueriesVolumeArgs = {
  id: Scalars['ID'];
};

export type Region = {
  __typename?: 'Region';
  /** The IATA airport code for this region */
  code: Scalars['String'];
  gatewayAvailable: Scalars['Boolean'];
  /** The latitude of this region */
  latitude?: Maybe<Scalars['Float']>;
  /** The longitude of this region */
  longitude?: Maybe<Scalars['Float']>;
  /** The name of this region */
  name: Scalars['String'];
  processGroup?: Maybe<Scalars['String']>;
};

export enum RegionEnum {
  /** Amsterdam, NL */
  Ams = 'AMS',
  /** Atlanta, US */
  Atl = 'ATL',
  /** Dallas, US */
  Dfw = 'DFW',
  /** New York, US */
  Ewr = 'EWR',
  /** Frankfurt, DE */
  Fra = 'FRA',
  /** Hong Kong, CN */
  Hkg = 'HKG',
  /** Virginia, US */
  Iad = 'IAD',
  /** Los Angeles, US */
  Lax = 'LAX',
  /** Tokyo, JP */
  Nrt = 'NRT',
  /** Chicago, US */
  Ord = 'ORD',
  /** Seattle, US */
  Sea = 'SEA',
  /** Singapore, SG */
  Sin = 'SIN',
  /** San Jose, US */
  Sjc = 'SJC',
  /** Sydney, AU */
  Syd = 'SYD',
  /** Toronto, CA */
  Yyz = 'YYZ'
}

export type RegionPlacement = {
  __typename?: 'RegionPlacement';
  /** The desired number of allocations */
  count?: Maybe<Scalars['Int']>;
  /** The region code */
  region: Scalars['String'];
};

/** Autogenerated input type of RegisterDomain */
export type RegisterDomainInput = {
  /** Enable auto renew on the registration */
  autoRenew?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the domain */
  domainId: Scalars['ID'];
  /** Enable whois privacy on the registration */
  whoisPrivacy?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of RegisterDomain */
export type RegisterDomainPayload = {
  __typename?: 'RegisterDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
};

export type Release = Node & {
  __typename?: 'Release';
  config?: Maybe<AppConfig>;
  createdAt: Scalars['ISO8601DateTime'];
  deploymentStrategy: DeploymentStrategy;
  /** A description of the release */
  description: Scalars['String'];
  evaluationId?: Maybe<Scalars['String']>;
  /** Unique ID */
  id: Scalars['ID'];
  /** Docker image */
  image?: Maybe<Image>;
  /** Docker image URI */
  imageRef?: Maybe<Scalars['String']>;
  /** @deprecated use deployment.inProgress */
  inProgress: Scalars['Boolean'];
  /** The reason for the release */
  reason: Scalars['String'];
  /** Version release reverted to */
  revertedTo?: Maybe<Scalars['Int']>;
  stable: Scalars['Boolean'];
  /** The status of the release */
  status: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
  /** The user who created the release */
  user?: Maybe<User>;
  /** The version of the release */
  version: Scalars['Int'];
};

export type ReleaseCommand = Node & {
  __typename?: 'ReleaseCommand';
  app: App;
  command: Scalars['String'];
  evaluationId?: Maybe<Scalars['String']>;
  exitCode?: Maybe<Scalars['Int']>;
  failed: Scalars['Boolean'];
  id: Scalars['ID'];
  inProgress: Scalars['Boolean'];
  instanceId?: Maybe<Scalars['String']>;
  status: Scalars['String'];
  succeeded: Scalars['Boolean'];
};

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: 'ReleaseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: 'ReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Release>;
};

/** Autogenerated input type of ReleaseIPAddress */
export type ReleaseIpAddressInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the ip address to release */
  ipAddressId: Scalars['ID'];
};

/** Autogenerated return type of ReleaseIPAddress */
export type ReleaseIpAddressPayload = {
  __typename?: 'ReleaseIPAddressPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export type RemoteDockerBuilderAppRole = AppRole & {
  __typename?: 'RemoteDockerBuilderAppRole';
  /** The name of this role */
  name: Scalars['String'];
};

/** Autogenerated input type of RemoveMachine */
export type RemoveMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** machine id */
  id: Scalars['String'];
  /** force kill machine if it's running */
  kill?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of RemoveMachine */
export type RemoveMachinePayload = {
  __typename?: 'RemoveMachinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  machine: Machine;
};

/** Autogenerated input type of RemoveWireGuardPeer */
export type RemoveWireGuardPeerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the peer to remove */
  name: Scalars['String'];
  /** Add via NATS transaction (for testing only, nosy users) */
  nats?: InputMaybe<Scalars['Boolean']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of RemoveWireGuardPeer */
export type RemoveWireGuardPeerPayload = {
  __typename?: 'RemoveWireGuardPeerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization that owned the peer */
  organization: Organization;
};

/** Autogenerated input type of ResetAddOnPassword */
export type ResetAddOnPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the add-on whose password should be reset */
  name: Scalars['String'];
};

/** Autogenerated return type of ResetAddOnPassword */
export type ResetAddOnPasswordPayload = {
  __typename?: 'ResetAddOnPasswordPayload';
  addOn: AddOn;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RestartAllocation */
export type RestartAllocationInput = {
  /** The ID of the app */
  allocId: Scalars['ID'];
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RestartAllocation */
export type RestartAllocationPayload = {
  __typename?: 'RestartAllocationPayload';
  allocation: Allocation;
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RestartApp */
export type RestartAppInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RestartApp */
export type RestartAppPayload = {
  __typename?: 'RestartAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RestoreVolumeSnapshot */
export type RestoreVolumeSnapshotInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  snapshotId: Scalars['ID'];
  volumeId: Scalars['ID'];
};

/** Autogenerated return type of RestoreVolumeSnapshot */
export type RestoreVolumeSnapshotPayload = {
  __typename?: 'RestoreVolumeSnapshotPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  snapshot: VolumeSnapshot;
  volume: Volume;
};

/** Autogenerated input type of ResumeApp */
export type ResumeAppInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ResumeApp */
export type ResumeAppPayload = {
  __typename?: 'ResumeAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RevokePostgresClusterUserAccess */
export type RevokePostgresClusterUserAccessInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The database to revoke access to */
  databaseName: Scalars['String'];
  /** The username to revoke */
  username: Scalars['String'];
};

/** Autogenerated return type of RevokePostgresClusterUserAccess */
export type RevokePostgresClusterUserAccessPayload = {
  __typename?: 'RevokePostgresClusterUserAccessPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  database: PostgresClusterDatabase;
  postgresClusterRole: PostgresClusterAppRole;
  user: PostgresClusterUser;
};

export enum RuntimeType {
  /** Fly Container Runtime */
  Firecracker = 'FIRECRACKER',
  /** Fly JavaScript Runtime */
  Nodeproxy = 'NODEPROXY'
}

/** Autogenerated input type of SaveDeploymentSource */
export type SaveDeploymentSourceInput = {
  /** The application to update */
  appId: Scalars['String'];
  baseDir?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  ref?: InputMaybe<Scalars['String']>;
  repositoryId: Scalars['String'];
  skipBuild?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of SaveDeploymentSource */
export type SaveDeploymentSourcePayload = {
  __typename?: 'SaveDeploymentSourcePayload';
  app?: Maybe<App>;
  build?: Maybe<Build>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ScaleApp */
export type ScaleAppInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Regions to scale */
  regions: Array<ScaleRegionInput>;
};

/** Autogenerated return type of ScaleApp */
export type ScaleAppPayload = {
  __typename?: 'ScaleAppPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  delta: Array<ScaleRegionChange>;
  placement: Array<RegionPlacement>;
};

export type ScaleRegionChange = {
  __typename?: 'ScaleRegionChange';
  /** The original value */
  fromCount: Scalars['Int'];
  /** The region code */
  region: Scalars['String'];
  /** The new value */
  toCount?: Maybe<Scalars['Int']>;
};

/** Region placement configuration */
export type ScaleRegionInput = {
  /** The value to change by */
  count: Scalars['Int'];
  /** The region to configure */
  region: Scalars['String'];
};

export enum SchedulingEnum {
  /** Ephemeral app, stays stopped on exit */
  Ephemeral = 'EPHEMERAL',
  /** Permanent app, restarts on exit */
  Permanent = 'PERMANENT'
}

export type Secret = Node & {
  __typename?: 'Secret';
  createdAt: Scalars['ISO8601DateTime'];
  /** The digest of the secret value */
  digest: Scalars['String'];
  id: Scalars['ID'];
  /** The name of the secret */
  name: Scalars['String'];
  /** The user who initiated the deployment */
  user?: Maybe<User>;
};

/** A secure configuration value */
export type SecretInput = {
  /** The unqiue key for this secret */
  key: Scalars['String'];
  /** The value of this secret */
  value: Scalars['String'];
};

/** Global port routing */
export type Service = {
  __typename?: 'Service';
  /** Health checks */
  checks: Array<Check>;
  description: Scalars['String'];
  /** Hard concurrency limit */
  hardConcurrency: Scalars['Int'];
  /** Application port to forward traffic to */
  internalPort: Scalars['Int'];
  /** Ports to listen on */
  ports: Array<ServicePort>;
  /** Protocol to listen on */
  protocol: ServiceProtocolType;
  /** Soft concurrency limit */
  softConcurrency: Scalars['Int'];
};

export enum ServiceHandlerType {
  /** Convert TCP connection to HTTP (at the edge) */
  EdgeHttp = 'EDGE_HTTP',
  /** Convert TCP connection to HTTP */
  Http = 'HTTP',
  /** Wrap TCP connection in PROXY protocol */
  ProxyProto = 'PROXY_PROTO',
  /** Convert TLS connection to unencrypted TCP */
  Tls = 'TLS'
}

/** Global port routing */
export type ServiceInput = {
  /** Health checks */
  checks?: InputMaybe<Array<CheckInput>>;
  /** Hard concurrency limit */
  hardConcurrency?: InputMaybe<Scalars['Int']>;
  /** Application port to forward traffic to */
  internalPort: Scalars['Int'];
  /** Ports to listen on */
  ports?: InputMaybe<Array<ServiceInputPort>>;
  /** Protocol to listen on */
  protocol: ServiceProtocolType;
  /** Soft concurrency limit */
  softConcurrency?: InputMaybe<Scalars['Int']>;
};

/** Service port */
export type ServiceInputPort = {
  /** Handlers to apply before forwarding service traffic */
  handlers?: InputMaybe<Array<ServiceHandlerType>>;
  /** Port to listen on */
  port: Scalars['Int'];
  /** tls options */
  tlsOptions?: InputMaybe<ServicePortTlsOptionsInput>;
};

/** Service port */
export type ServicePort = {
  __typename?: 'ServicePort';
  /** Handlers to apply before forwarding service traffic */
  handlers: Array<ServiceHandlerType>;
  /** Port to listen on */
  port: Scalars['Int'];
};

/** TLS handshakes options for a port */
export type ServicePortTlsOptionsInput = {
  defaultSelfSigned?: InputMaybe<Scalars['Boolean']>;
};

export enum ServiceProtocolType {
  /** TCP protocol */
  Tcp = 'TCP',
  /** UDP protocl */
  Udp = 'UDP'
}

/** Autogenerated input type of SetPagerdutyHandler */
export type SetPagerdutyHandlerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Handler name */
  name: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** Map of alert severity levels to PagerDuty severity levels */
  pagerdutyStatusMap?: InputMaybe<Scalars['JSON']>;
  /** PagerDuty API token */
  pagerdutyToken: Scalars['String'];
};

/** Autogenerated return type of SetPagerdutyHandler */
export type SetPagerdutyHandlerPayload = {
  __typename?: 'SetPagerdutyHandlerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  handler: HealthCheckHandler;
};

/** Autogenerated input type of SetSecrets */
export type SetSecretsInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** By default, we set only the secrets you specify. Set this to true to replace all secrets. */
  replaceAll?: InputMaybe<Scalars['Boolean']>;
  /** Secrets to set */
  secrets: Array<SecretInput>;
};

/** Autogenerated return type of SetSecrets */
export type SetSecretsPayload = {
  __typename?: 'SetSecretsPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  release?: Maybe<Release>;
};

/** Autogenerated input type of SetSlackHandler */
export type SetSlackHandlerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Handler name */
  name: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** Slack channel to send messages to, defaults to #general */
  slackChannel?: InputMaybe<Scalars['String']>;
  /** Icon to show with Slack messages */
  slackIconUrl?: InputMaybe<Scalars['String']>;
  /** User name to display on Slack Messages (defaults to Fly) */
  slackUsername?: InputMaybe<Scalars['String']>;
  /** Slack Webhook URL to use for health check notifications */
  slackWebhookUrl: Scalars['String'];
};

/** Autogenerated return type of SetSlackHandler */
export type SetSlackHandlerPayload = {
  __typename?: 'SetSlackHandlerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  handler: HealthCheckHandler;
};

/** Autogenerated input type of SetVMCount */
export type SetVmCountInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Counts for VM groups */
  groupCounts: Array<VmCountInput>;
};

/** Autogenerated return type of SetVMCount */
export type SetVmCountPayload = {
  __typename?: 'SetVMCountPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  release?: Maybe<Release>;
  taskGroupCounts: Array<TaskGroupCount>;
  warnings: Array<Scalars['String']>;
};

/** Autogenerated input type of SetVMSize */
export type SetVmSizeInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Process group to modify */
  group?: InputMaybe<Scalars['String']>;
  /** Optionally request more memory */
  memoryMb?: InputMaybe<Scalars['Int']>;
  /** The name of the vm size to set */
  sizeName: Scalars['String'];
};

/** Autogenerated return type of SetVMSize */
export type SetVmSizePayload = {
  __typename?: 'SetVMSizePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Process Group scale change applied to (if any) */
  processGroup?: Maybe<ProcessGroup>;
  /** Default app vm size */
  vmSize?: Maybe<VmSize>;
};

/** Autogenerated input type of StartBuild */
export type StartBuildInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of StartBuild */
export type StartBuildPayload = {
  __typename?: 'StartBuildPayload';
  build: Build;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of StartMachine */
export type StartMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** machine id */
  id: Scalars['String'];
};

/** Autogenerated return type of StartMachine */
export type StartMachinePayload = {
  __typename?: 'StartMachinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  machine: Machine;
};

/** Autogenerated input type of StopAllocation */
export type StopAllocationInput = {
  /** The ID of the app */
  allocId: Scalars['ID'];
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of StopAllocation */
export type StopAllocationPayload = {
  __typename?: 'StopAllocationPayload';
  allocation: Allocation;
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of StopMachine */
export type StopMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** machine id */
  id: Scalars['String'];
  /** how long to wait before force killing the machine */
  killTimeoutSecs?: InputMaybe<Scalars['Int']>;
  /** signal to send the machine */
  signal?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of StopMachine */
export type StopMachinePayload = {
  __typename?: 'StopMachinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  machine: Machine;
};

export type TaskGroupCount = {
  __typename?: 'TaskGroupCount';
  count: Scalars['Int'];
  name: Scalars['String'];
};

export type TemplateDeployment = Node & {
  __typename?: 'TemplateDeployment';
  apps: AppConnection;
  id: Scalars['ID'];
  organization: Organization;
  status: Scalars['String'];
};


export type TemplateDeploymentAppsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of UnsetSecrets */
export type UnsetSecretsInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Secret keys to unset */
  keys: Array<Scalars['String']>;
};

/** Autogenerated return type of UnsetSecrets */
export type UnsetSecretsPayload = {
  __typename?: 'UnsetSecretsPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  release?: Maybe<Release>;
};

/** Autogenerated input type of UpdateAddOn */
export type UpdateAddOnInput = {
  /** The add-on ID to update */
  addOnId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The add-on name to update */
  name?: InputMaybe<Scalars['String']>;
  /** The add-on plan ID */
  planId?: InputMaybe<Scalars['ID']>;
  /** Desired regions to place replicas in */
  readRegions?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of UpdateAddOn */
export type UpdateAddOnPayload = {
  __typename?: 'UpdateAddOnPayload';
  addOn: AddOn;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateAutoscaleConfig */
export type UpdateAutoscaleConfigInput = {
  /** The ID of the app */
  appId: Scalars['ID'];
  balanceRegions?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  maxCount?: InputMaybe<Scalars['Int']>;
  minCount?: InputMaybe<Scalars['Int']>;
  /** Region configs */
  regions?: InputMaybe<Array<AutoscaleRegionConfigInput>>;
  resetRegions?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateAutoscaleConfig */
export type UpdateAutoscaleConfigPayload = {
  __typename?: 'UpdateAutoscaleConfigPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateDNSPortal */
export type UpdateDnsPortalInput = {
  /** The secondary branding color */
  accentColor?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  dnsPortalId: Scalars['ID'];
  /** The unique name of this portal. */
  name?: InputMaybe<Scalars['String']>;
  /** The primary branding color */
  primaryColor?: InputMaybe<Scalars['String']>;
  /** The return url for this portal */
  returnUrl?: InputMaybe<Scalars['String']>;
  /** The text to display for the return url link */
  returnUrlText?: InputMaybe<Scalars['String']>;
  /** The support url for this portal */
  supportUrl?: InputMaybe<Scalars['String']>;
  /** The text to display for the support url link */
  supportUrlText?: InputMaybe<Scalars['String']>;
  /** The title of this portal */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateDNSPortal */
export type UpdateDnsPortalPayload = {
  __typename?: 'UpdateDNSPortalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  dnsPortal: DnsPortal;
};

/** Autogenerated input type of UpdateDNSRecord */
export type UpdateDnsRecordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The dns record name */
  name?: InputMaybe<Scalars['String']>;
  /** The content of the record */
  rdata?: InputMaybe<Scalars['String']>;
  /** The node ID of the DNS record */
  recordId: Scalars['ID'];
  /** The TTL in seconds */
  ttl?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateDNSRecord */
export type UpdateDnsRecordPayload = {
  __typename?: 'UpdateDNSRecordPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  record: DnsRecord;
};

/** Autogenerated input type of UpdateDNSRecords */
export type UpdateDnsRecordsInput = {
  changes: Array<DnsRecordChangeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the domain */
  domainId: Scalars['ID'];
};

/** Autogenerated return type of UpdateDNSRecords */
export type UpdateDnsRecordsPayload = {
  __typename?: 'UpdateDNSRecordsPayload';
  changes: Array<DnsRecordDiff>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  domain: Domain;
  warnings: Array<DnsRecordWarning>;
};

/** Autogenerated input type of UpdateOrganizationMembership */
export type UpdateOrganizationMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
  /** The new role for the user */
  role: OrganizationMemberRole;
  /** The node ID of the user */
  userId: Scalars['ID'];
};

/** Autogenerated return type of UpdateOrganizationMembership */
export type UpdateOrganizationMembershipPayload = {
  __typename?: 'UpdateOrganizationMembershipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
  user: User;
};

/** Autogenerated input type of UpdateRemoteBuilder */
export type UpdateRemoteBuilderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Docker image reference */
  image: Scalars['String'];
  /** The node ID of the organization */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRemoteBuilder */
export type UpdateRemoteBuilderPayload = {
  __typename?: 'UpdateRemoteBuilderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organization: Organization;
};

export type User = Node & {
  __typename?: 'User';
  /** URL for avatar or placeholder */
  avatarUrl: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Email address for user (private) */
  email: Scalars['String'];
  featureFlags: Array<Scalars['String']>;
  hasNodeproxyApps: Scalars['Boolean'];
  id: Scalars['ID'];
  lastRegion?: Maybe<Scalars['String']>;
  /** Display / full name for user (private) */
  name?: Maybe<Scalars['String']>;
  /** @deprecated Use query.organizations instead */
  organizations: OrganizationConnection;
  /** @deprecated Use query.personalOrganization instead */
  personalOrganization: Organization;
  trust: OrganizationTrust;
  twoFactorProtection: Scalars['Boolean'];
  /** Public username for user */
  username?: Maybe<Scalars['String']>;
};


export type UserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type Vm = Node & {
  __typename?: 'VM';
  attachedVolumes: VolumeConnection;
  canary: Scalars['Boolean'];
  checks: Array<CheckState>;
  createdAt: Scalars['ISO8601DateTime'];
  criticalCheckCount: Scalars['Int'];
  /** Desired status */
  desiredStatus: Scalars['String'];
  events: Array<AllocationEvent>;
  failed: Scalars['Boolean'];
  healthy: Scalars['Boolean'];
  /** Unique ID for this instance */
  id: Scalars['ID'];
  /** Short unique ID for this instance */
  idShort: Scalars['ID'];
  /** Indicates if this instance is from the latest job version */
  latestVersion: Scalars['Boolean'];
  passingCheckCount: Scalars['Int'];
  /** Private IPv6 address for this instance */
  privateIP?: Maybe<Scalars['String']>;
  recentLogs: Array<LogEntry>;
  /** Region this allocation is running in */
  region: Scalars['String'];
  restarts: Scalars['Int'];
  /** Current status */
  status: Scalars['String'];
  taskName: Scalars['String'];
  totalCheckCount: Scalars['Int'];
  transitioning: Scalars['Boolean'];
  updatedAt: Scalars['ISO8601DateTime'];
  /** The configuration version of this instance */
  version: Scalars['Int'];
  warningCheckCount: Scalars['Int'];
};


export type VmAttachedVolumesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type VmChecksArgs = {
  name?: InputMaybe<Scalars['String']>;
};


export type VmRecentLogsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  range?: InputMaybe<Scalars['Int']>;
};

/** The connection type for VM. */
export type VmConnection = {
  __typename?: 'VMConnection';
  activeCount: Scalars['Int'];
  completeCount: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VmEdge>>>;
  failedCount: Scalars['Int'];
  inactiveCount: Scalars['Int'];
  lostCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Vm>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  pendingCount: Scalars['Int'];
  runningCount: Scalars['Int'];
  totalCount: Scalars['Int'];
};

export type VmCountInput = {
  /** The desired count */
  count?: InputMaybe<Scalars['Int']>;
  /** VM group name */
  group?: InputMaybe<Scalars['String']>;
  /** Max number of VMs to allow per region */
  maxPerRegion?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type VmEdge = {
  __typename?: 'VMEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Vm>;
};

export type VmSize = {
  __typename?: 'VMSize';
  cpuCores: Scalars['Float'];
  maxMemoryMb: Scalars['Int'];
  memoryGb: Scalars['Float'];
  memoryIncrementsMb: Array<Scalars['Int']>;
  memoryMb: Scalars['Int'];
  name: Scalars['String'];
  priceMonth: Scalars['Float'];
  priceSecond: Scalars['Float'];
};

export enum VmSizeEnum {
  /** Dedicated 1x CPU core, 2GB */
  DedicatedCpu_1X = 'DEDICATED_CPU_1X',
  /** Dedicated 2x CPU core, 4GB */
  DedicatedCpu_2X = 'DEDICATED_CPU_2X',
  /** Dedicated 4x CPU core, 8GB */
  DedicatedCpu_4X = 'DEDICATED_CPU_4X',
  /** Dedicated 8x CPU core, 16GB */
  DedicatedCpu_8X = 'DEDICATED_CPU_8X',
  /** Shared 1x CPU core, 256MB */
  SharedCpu_1X = 'SHARED_CPU_1X'
}

/** Autogenerated input type of ValidateWireGuardPeers */
export type ValidateWireGuardPeersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  peerIps: Array<Scalars['String']>;
};

/** Autogenerated return type of ValidateWireGuardPeers */
export type ValidateWireGuardPeersPayload = {
  __typename?: 'ValidateWireGuardPeersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  invalidPeerIps: Array<Scalars['String']>;
  validPeerIps: Array<Scalars['String']>;
};

export type Volume = Node & {
  __typename?: 'Volume';
  app: App;
  attachedAllocation?: Maybe<Allocation>;
  attachedMachine?: Maybe<Machine>;
  createdAt: Scalars['ISO8601DateTime'];
  encrypted: Scalars['Boolean'];
  host: Host;
  id: Scalars['ID'];
  internalId: Scalars['String'];
  name: Scalars['String'];
  region: Scalars['String'];
  sizeGb: Scalars['Int'];
  snapshots: VolumeSnapshotConnection;
  state: Scalars['String'];
  status: Scalars['String'];
  usedBytes: Scalars['BigInt'];
};


export type VolumeSnapshotsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Volume. */
export type VolumeConnection = {
  __typename?: 'VolumeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VolumeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Volume>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type VolumeEdge = {
  __typename?: 'VolumeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Volume>;
};

export type VolumeInput = {
  /** How many volumes to create with this configuration */
  count?: InputMaybe<Scalars['Int']>;
  /** Volume should be encrypted at rest */
  encrypted?: InputMaybe<Scalars['Boolean']>;
  /** Volume name */
  name: Scalars['String'];
  /** Desired region for volume */
  region: RegionEnum;
  /** Desired volume size, in GB */
  sizeGb: Scalars['Int'];
};

export type VolumeSnapshot = Node & {
  __typename?: 'VolumeSnapshot';
  createdAt: Scalars['ISO8601DateTime'];
  digest: Scalars['String'];
  id: Scalars['ID'];
  size: Scalars['BigInt'];
  volume: Volume;
};

/** The connection type for VolumeSnapshot. */
export type VolumeSnapshotConnection = {
  __typename?: 'VolumeSnapshotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VolumeSnapshotEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VolumeSnapshot>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type VolumeSnapshotEdge = {
  __typename?: 'VolumeSnapshotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VolumeSnapshot>;
};

export type WireGuardPeer = Node & {
  __typename?: 'WireGuardPeer';
  gatewayStatus: Scalars['JSON'];
  id: Scalars['ID'];
  name: Scalars['String'];
  network?: Maybe<Scalars['String']>;
  peerip: Scalars['String'];
  pubkey: Scalars['String'];
  region: Scalars['String'];
};

/** The connection type for WireGuardPeer. */
export type WireGuardPeerConnection = {
  __typename?: 'WireGuardPeerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WireGuardPeerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WireGuardPeer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type WireGuardPeerEdge = {
  __typename?: 'WireGuardPeerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<WireGuardPeer>;
};

export type CreateAppMutationVariables = Exact<{
  input: CreateAppInput;
}>;


export type CreateAppMutation = { __typename?: 'Mutations', createApp?: { __typename?: 'CreateAppPayload', app: { __typename?: 'App', id: string, hostname?: string | null } } | null };

export type CreateVolumeMutationVariables = Exact<{
  input: CreateVolumeInput;
}>;


export type CreateVolumeMutation = { __typename?: 'Mutations', createVolume?: { __typename?: 'CreateVolumePayload', clientMutationId?: string | null } | null };

export type DeleteAppMutationVariables = Exact<{
  appId: Scalars['ID'];
}>;


export type DeleteAppMutation = { __typename?: 'Mutations', deleteApp?: { __typename: 'DeleteAppPayload' } | null };

export type DeployImageMutationVariables = Exact<{
  input: DeployImageInput;
}>;


export type DeployImageMutation = { __typename?: 'Mutations', deployImage?: { __typename?: 'DeployImagePayload', clientMutationId?: string | null } | null };

export type SetSecretsMutationVariables = Exact<{
  input: SetSecretsInput;
}>;


export type SetSecretsMutation = { __typename?: 'Mutations', setSecrets?: { __typename?: 'SetSecretsPayload', clientMutationId?: string | null } | null };


export const CreateAppDocument = gql`
    mutation CreateApp($input: CreateAppInput!) {
  createApp(input: $input) {
    app {
      id
      hostname
    }
  }
}
    `;
export const CreateVolumeDocument = gql`
    mutation CreateVolume($input: CreateVolumeInput!) {
  createVolume(input: $input) {
    clientMutationId
  }
}
    `;
export const DeleteAppDocument = gql`
    mutation DeleteApp($appId: ID!) {
  deleteApp(appId: $appId) {
    __typename
  }
}
    `;
export const DeployImageDocument = gql`
    mutation DeployImage($input: DeployImageInput!) {
  deployImage(input: $input) {
    clientMutationId
  }
}
    `;
export const SetSecretsDocument = gql`
    mutation SetSecrets($input: SetSecretsInput!) {
  setSecrets(input: $input) {
    clientMutationId
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    CreateApp(variables: CreateAppMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CreateAppMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateAppMutation>(CreateAppDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateApp', 'mutation');
    },
    CreateVolume(variables: CreateVolumeMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CreateVolumeMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateVolumeMutation>(CreateVolumeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateVolume', 'mutation');
    },
    DeleteApp(variables: DeleteAppMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DeleteAppMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeleteAppMutation>(DeleteAppDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DeleteApp', 'mutation');
    },
    DeployImage(variables: DeployImageMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DeployImageMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeployImageMutation>(DeployImageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DeployImage', 'mutation');
    },
    SetSecrets(variables: SetSecretsMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<SetSecretsMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SetSecretsMutation>(SetSecretsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'SetSecrets', 'mutation');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;